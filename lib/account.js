//
//  Author: Vlad Seryakov vseryakov@gmail.com
//  backendjs 2018
//

const fs = require("fs");
const core = require(__dirname + '/core');
const lib = require(__dirname + '/lib');
const api = require(__dirname + '/api');
const logger = require(__dirname + '/logger');

// User and account management

const mod = {
    name: "account",
    priority: 99999,
    args: [
        { name: "table", descr: "Table to use for user accounts" },
        { name: "err-(.+)", descr: "Error messages for various cases" },
        { name: "cap-(.+)", type: "int", strip: "cap-", descr: "Capability parameters" },
        { name: "admin-roles", type: "list", descr: "List of special super admin roles" },
        { name: "sigversion", type: "int", descr: "Signature version for secrets" },
        { name: "max-length", type: "int", descr: "Max login and name length" },
        { name: "users", type: "json", logger: "error", descr: "An object with users" },
        { name: "file", descr: "A JSON file with users" },
        { name: "passkey-(.+)", obj: "passkey", autotype: 1, descr: "Passkey numeric parameters: path, secret, cache, max, ttl, disabled" },
    ],
    table: "bk_user",
    sigversion: -1,
    maxLength: 140,
    users: {},
    adminRoles: ["root", "admin"],
    passkey: {
        ttl: 30000,
        max: 5,
    },

    errInvalidSecret: "Invalid user name or password",
    errInvalidUser: "The username is required",
    errInvalidPasswd: "The password is required",
    errInvalidName: "The name is required",
    errInvalidParams: "No username or id provided",
    errInvalidId: "Invalid id provided",
    errInvalidLogin: "No username or password provided",
    errPasskeyChallenge: "Your passkey request has expired, please try again",
    errPasskeyRegistration: "Passkey provided cannot be registered, please try again",
    errPasskeyVerification: "Passkey provided cannot be verified, please try again",
    errPasskeyMax: "No more passkeys can be added to your account",
};
module.exports = mod;

mod.configure = function(options, callback)
{
    this.tables = {
        [this.table]: {
            login: {                                                     // User login/username
                primary: 1,
                max: mod.maxLength,
                keyword: 1,
            },
            id: {                                                        // Autogenerated ID
                type: "uuid",
                pub: 1,
                prefix: "u_",
                unique: 1,
                keyword: 1,
            },
            name: {                                                      // User name
                type: "text",
                pub: 1,
                notempty: 1,
                max: mod.maxLength,
            },
            status: { type: "text", max: mod.maxLength },                // Status of the account
            secret: { priv: 1, max: mod.maxLength },                     // Signature secret or password
            type: {                                                      // Account roles: admin, ....
                type: "list",
                list: 1,
                lower: 1,
                internal: 1,
                keyword: 1,
            },
            flags: {                                                      // Tags/flags about the account
                type: "list",
                list: 1,
                max: mod.maxLength,
                keyword: 1,
            },
            expires: { type: "bigint", internal: 1, priv: 1 },           // Deny access to the account if this value is before current date, ms
            ctime: { type: "now", readonly: 1 },                         // Create time
            mtime: { type: "now" },                                      // Modified time
            device_id: { type: "text", priv: 1, max: 4096 },             // Device(s) for push notifications: [service://]token[@appname]
            passkey: { type: "text", internal: 1, priv: 1, max: 4096 },  // List of registered passkeys in json format
        },
    };

    this.loadFile((err) => {
        if (err) return;
        fs.watch(this.file, () => {
            core.setTimeout(this.usersFile, this.loadFile.bind(this), lib.randomInt(1000, 5000));
        });
    });

    callback();
}

mod.configureWeb = function(options, callback)
{
    this.configureLoginAPI(options);
    this.configurePasskeyAPI(options);
    this.configureAccountAPI(options);

    callback();
}

mod.configureLoginAPI = function(options)
{
    if (this.nologin) return;

    // Authentication check with signature/session
    api.app.post(/^\/auth$/, (req, res) => {
        if (!req.account?.id) {
            return api.sendReply(res, { status: 417, message: mod.errInvalidLogin, code: "NOLOGIN" });
        }
        api.handleSessionSignature(req, () => {
            req.options.cleanup = mod.table;
            req.options.cleanup_strict = 1;
            api.sendJSON(req, null, req.account);
        });
    });

    // Login with just the secret without signature
    api.app.post(/^\/login$/, (req, res) => {
        if (!req.query.login || !req.query.secret) {
            return api.sendReply(res, { status: 417, message: mod.errInvalidLogin, code: "NOLOGIN" });
        }
        // Create internal signature from the login data
        req.signature = api.newSignature(req, "version", mod.sigversion, "source", "l", "login", req.query.login, "secret", req.query.secret);
        delete req.query.login;
        delete req.query.secret;
        api.checkRequestSignature(req, (err) => {
            if (!req.account?.id) {
                return api.sendJSON(req, err || { status: 417, message: mod.errInvalidLogin, code: "NOLOGIN" });
            }
            api.handleSessionSignature(req, () => {
                req.options.cleanup = mod.table;
                req.options.cleanup_strict = 1;
                api.sendJSON(req, null, req.account);
            });
        });
    });

    // Clear sessions and access tokens
    api.app.post(/^\/logout$/, (req, res) => {
        api.handleLogout(req);
        api.sendJSON(req);
    });
}

// Account methods below use request context and fire bk...Account hooks
mod.configureAccountAPI = function(options)
{
    if (this.noaccount) return;

    api.app.post(/^\/account\/update$/, function(req, res, next) {
        var options = api.getOptions(req);
        options.cleanup = mod.table;
        options.cleanup_strict = 1;

        mod.updateAccount(req, options, (err, data) => {
            api.sendJSON(req, err, data);
        });
    });

    api.app.all(/^\/account\/([a-z/]+)$/, function(req, res, next) {
        var options = api.getOptions(req);
        options.cleanup = mod.table;
        options.cleanup_strict = 1;

        switch (req.params[0]) {
        case "get":
            mod.getAccount(req, options, (err, data, info) => {
                api.sendJSON(req, err, data);
            });
            break;


        case "ws":
        case "ws/query":
        case "ws/account":
            core.runMethods("bkWebsocketRequest", { wsid: req.wsid, account: req.account, query: req.query, options: req.options }, () => {
                var key = req.params[0].split("/").pop();
                if (key) api.wsSet(key, req, req[key]);
                res.send("");
            });
            break;

        default:
            api.sendReply(res, 400, "Invalid command");
        }
    });
}

// Returns current account, used in /account/get API call, req.account will be filled with the properties from the db
mod.getAccount = function(req, options, callback)
{
    if (typeof options == "function") callback = options, options = null;
    if (!req.account?.id) return callback({ status: 400, message: "invalid account" });
    mod.get({ login: req.account.login, id: req.account.id }, options, (err, row, info) => {
        if (err || !row) return callback(err || { status: 404, message: "account not found" });
        for (const p in row) req.account[p] = row[p];
        callback(null, req.account, info);
    });
}

// Register new account, may be used an API call, but the req does not have to be an Express request, it just
// need to have query and options objects.
mod.addAccount = function(req, options, callback)
{
    if (typeof options == "function") callback = options, options = null;

    lib.series([
        function(next) {
            req.stopOnError = 1;
            core.runMethods("bkPrepareAddAccount", req, { logger_allow: ["query", ...api.requestCleanup] }, next);
        },
        function(next) {
            mod.add(req.query, options, (err, row) => {
                if (!err) {
                    // Link account record for other middleware
                    api.setCurrentAccount(req, row);
                }
                next(err);
            });
        },
        function(next) {
            core.runMethods("bkAddAccount", req, { logger_allow: ["query", ...api.requestCleanup] }, next);
        },
    ], (err) => {
        lib.tryCall(callback, err, req.query);
    }, true);
}

// Update existing account, used in /account/update API call
mod.updateAccount = function(req, options, callback)
{
    if (typeof options == "function") callback = options, options = null;

    req.query.id = req.account.id;
    req.query.login = req.account.login;

    lib.series([
        function(next) {
            req.stopOnError = 1;
            core.runMethods("bkPrepareUpdateAccount", req, { logger_allow: ["query", ...api.requestCleanup] }, next);
        },
        function(next) {
            mod.update(req.query, options, next);
        },
        function(next) {
            delete req.stopOnError;
            core.runMethods("bkUpdateAccount", req, { logger_allow: ["query", ...api.requestCleanup] }, next);
        },
    ], (err) => {
        lib.tryCall(callback, err, req.query);
    }, true);
}

// Delete account specified by the obj.
// The options may contain `keep` array with tables to be kept, for example
// delete an account but keep all messages and location: keep:["bk_user","bk_location"]
//
// This methods is suitable for background jobs
mod.deleteAccount = function(req, callback)
{
    var started = Date.now();

    lib.series([
        function(next) {
            mod.get(req.account, req.options, next);
        },
        function(next, user) {
            if (!user && !req.options?.force) return next({ status: 404, message: "No account found" });
            for (const p in user) req.account[p] = user[p];
            req.account.type = lib.toFlags("add", req.account.type, "deleted");
            if (!req.options) req.options = {};
            if (!req.query) req.query = {};

            req.options.count = 0;
            req.stopOnError = 1;
            core.runMethods("bkPrepareDeleteAccount", req, { logger_allow: ["query", ...api.requestCleanup] }, next);
        },
        function(next) {
            if (!lib.isFlag(req.options.keep, ["all", "account", mod.table])) return next();
            mod.update({ id: req.account.id, login: req.account.login, type: req.account.type }, req.options, next);
        },
        function(next) {
            delete req.stopOnError;
            core.runMethods("bkDeleteAccount", req, { logger_allow: ["query", ...api.requestCleanup] }, next);
        },
        function(next) {
            if (lib.isFlag(req.options.keep, ["all", "account", mod.table])) return next();
            mod.del(req.account, req.options, next);
        },
     ], (err) => {
        logger.info("deleteAccount:", err, req.account, req.options, lib.toAge(started));
        lib.tryCall(callback, err);
    }, true);
}

require(__dirname + "/account/utils")
require(__dirname + "/account/passkey")
