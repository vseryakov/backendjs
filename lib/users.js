//
//  Author: Vlad Seryakov vseryakov@gmail.com
//  backendjs 2018
//

const fs = require("fs");
const util = require("util");
const crypto = require("node:crypto");
const lib = require(__dirname + '/lib');
const logger = require(__dirname + '/logger');
const db = require(__dirname + '/db');
const core = require(__dirname + '/core');

const mod = {
    name: "users",
    args: [
        { name: "table", descr: "Table to use for users" },
        { name: "err-(.+)", descr: "Error messages for various cases" },
        { name: "cap-(.+)", type: "int", strip: "cap-", descr: "Capability parameters" },
        { name: "max-length", type: "int", descr: "Max login and name length" },
        { name: "users", type: "json", logger: "error", descr: "An object with users" },
        { name: "file", descr: "A JSON file with users" },
    ],
    table: "bk_user",
    maxLength: 140,
    users: {},

    errInvalidSecret: "Invalid user name or password",
    errInvalidUser: "The username is required",
    errInvalidPasswd: "The password is required",
    errInvalidName: "The name is required",
    errInvalidParams: "No username or id provided",
    errInvalidId: "Invalid id provided",
};
module.exports = mod;

mod.configure = function(options, callback)
{
    this.tables = {
        [this.table]: {
            login: {                                                     // User login/username
                primary: 1,
                max: mod.maxLength,
                keyword: 1,
            },
            id: {                                                        // Autogenerated ID
                type: "uuid",
                pub: 1,
                prefix: "u_",
                unique: 1,
                keyword: 1,
            },
            name: {                                                      // User name
                type: "text",
                pub: 1,
                notempty: 1,
                max: mod.maxLength,
            },
            secret: { priv: 1, max: mod.maxLength },                     // Signature secret or password
            type: {                                                      // Permission roles: admin, ....
                type: "list",
                list: 1,
                lower: 1,
                internal: 1,
                keyword: 1,
            },
            flags: {                                                      // Tags/flags
                type: "list",
                list: 1,
                max: mod.maxLength,
                keyword: 1,
            },
            expires: { type: "bigint", internal: 1, priv: 1 },           // Deny access if this value is before current date, ms
            ctime: { type: "now", readonly: 1 },                         // Create time
            mtime: { type: "now" },                                      // Modified time
            device_id: { type: "text", priv: 1, max: 4096 },             // Device(s) for push notifications: [service://]token[@appname]
            passkey: { type: "text", internal: 1, priv: 1, max: 4096 },  // List of registered passkeys in json format
        },
    };

    this.loadFile((err) => {
        if (err) return;
        fs.watch(this.file, () => {
            core.setTimeout(this.usersFile, this.loadFile.bind(this), lib.randomInt(1000, 5000));
        });
    });

    callback();
}

// Returns a user record by login or id, to make use of a cache add to the config `db-cache-keys-bk_user-id=id`
mod.get = function(query, options, callback)
{
    if (typeof options == "function") callback = options, options = null;
    if (typeof query == "string") {
        query = { [lib.isUuid(query) ? "id" : "login"]: query };
    }
    if (query?.login) {
        var user = this.users[query.login];
        if (user) return callback(null, user);
        db.get(this.table, query, callback);
    } else
    if (query?.id) {
        for (const p in this.users) {
            if (this.users[p].id == query.id) return callback(null, this.users[p]);
        }
        var opts = { noscan: 1, cacheKeyName: "id", ops: { id: "eq" }, count: 1, first: 1 };
        db.select(this.table, { id: query.id }, opts, (err, row, info) => {
            if (!row) return callback(err);
            // For databases that do not support all columns with indexes(DynamoDB) we have to re-read by the primary key
            if (row.name && row.mtime) return callback(null, row, info);
            db.get(this.table, { login: row.login }, callback);
        });
    } else {
        callback();
    }
}
mod.aget = util.promisify(mod.get.bind(mod));

// Registers a new user, returns new record in the callback,
// if `options.isInternal` is true then allow to set all properties
// `options.internalQuery` can be used to add restricted properties if not in isInternal mode
// otherwise internal properties will not be added
mod.add = function(query, options, callback)
{
    if (typeof options == "function") callback = options, options = null;
    if (!query.login) return lib.tryCall(callback, { status: 400, message: this.errInvalidUser });
    if (!query.secret) return lib.tryCall(callback, { status: 400, message: this.errInvalidPasswd });
    if (!query.name) return lib.tryCall(callback, { status: 400, message: this.errInvalidName });

    options = lib.objClone(options, "result_obj", 1, "first", 1);
    query = Object.assign({}, query);

    this.prepareSecret(query, options, (err) => {
        if (err) return lib.tryCall(callback, err);

        if (!options.isInternal) {
            db.clearQuery(this.table, query, "internal");
        }
        Object.assign(query, options?.internalQuery);
        delete query.id;

        db.add(this.table, query, options, (err, row, info) => {
            if (!err) {
                Object.assign(query, row);
            }
            lib.tryCall(callback, err, query, info);
        });
    });
}
mod.aadd = util.promisify(mod.add.bind(mod));

// Updates an existing user by login or id,
// if `options.isInternal` is true then allow to update all properties,
// `options.internalQuery` can be used to add restricted properties if not in isInternal mode
// returns a new record in the callback
mod.update = function(query, options, callback)
{
    if (typeof options == "function") callback = options, options = null;
    options = lib.objClone(options, "returning", "*", "first", 1);
    query = Object.assign({}, query);

    this.prepareSecret(query, options, (err) => {
        if (err) return lib.tryCall(callback, err);

        if (!options.isInternal) {
            db.clearQuery(this.table, query, "internal");
            if (query.login) delete query.id;
        }
        Object.assign(query, options?.internalQuery);
        if (!query.name) delete query.name;
        if (!this.isUid(query.id)) delete query.id;

        if (query.login) {
            db.update(this.table, query, options, callback);
        } else
        if (query.id) {
            db.select(this.table, { id: query.id }, { cacheKeyName: "id", count: 1, first: 1 }, (err, row) => {
                if (!row) return callback(err, { status: 404, message: this.errInvalidId });

                query.login = row.login;
                db.update(this.table, query, options, callback);
            });
        } else {
            lib.tryCall(callback, { status: 400, message: this.errInvalidParams });
        }
    });
}
mod.aupdate = util.promisify(mod.update.bind(mod));

// Deletes an existing user by login or id, no admin checks, returns the old record in the callback
mod.del = function(query, options, callback)
{
    if (typeof options == "function") callback = options, options = null;
    if (typeof query == "string") {
        query = { [this.isUid(query) ? "id" : "login"]: query };
    }
    options = lib.objClone(options, "returning", "old", "first", 1);
    query = Object.assign({}, query, options?.query);

    if (query.login) {
        db.del(this.table, query, options, callback);
    } else
    if (query.id) {
        db.select(this.table, { id: query.id }, { cacheKeyName: "id", count: 1, first: 1 }, (err, row) => {
            if (!row) return callback(err, { status: 404, message: this.errInvalidId });

            query.login = row.login;
            db.del(this.table, query, options, callback);
        });
    } else {
        lib.tryCall(callback, { status: 400, message: this.errInvalidParams });
    }
}
mod.adel = util.promisify(mod.del.bind(mod));

// Returns true of the given id is a valid user uuid
mod.isUid = function(id)
{
    return lib.isUuid(id, this.tables[this.table].id.prefix);
}

// If specified in the options, prepare credentials to be stored in the db, if no error occurred return null, otherwise an error object
mod.prepareSecret = function(query, options, callback)
{
    if (typeof options == "function") callback = options, options = null;
    if (!options) options = {};

    if (!query.secret) delete query.secret;

    lib.series([
        function(next) {
            if (!query.secret) return next();
            var salt = crypto.randomBytes(16).toString("base64");
            crypto.scrypt(query.secret, salt, 64, (err, key) => {
                if (!err) query.secret = key.toString("base64") + ":" + salt;
                next(err);
            });
        },
    ], callback);
}

// Verify an existing user record with given password,
//  - user - if a string it is a hashed secret from an existing user record, otherwise must be an user object
//  - password - plain text password or other secret passed to be verified
mod.checkSecret = function(user, password, callback)
{
    if (typeof user == "string") user = { secret: user };
    if (!user?.secret || !password) {
        return callback({ status: 400, message: this.errInvalidSecret });
    }

    // Exact
    if (user.secret == password) return callback();

    lib.series([
        function(next) {
            if (!/^\$2b\$/.test(user.secret)) return next();
            if (!mod.bcryptMod) mod.bcryptMod = require('bcrypt');
            mod.bcryptMod.compare(password, user.secret, (err, rc) => {
                if (!rc) return next(1);
                // Convert to scrypt
                user.secret = password;
                mod.prepareSecret(user, (err) => {
                    if (err) return next(err);
                    db.update(mod.table, { login: user.login, secret: user.secret }, callback);
                });
            });
        },
        function(next) {
            var [secret, salt] = lib.strSplit(user.secret, ":");
            if (!secret || !salt) return next();
            crypto.scrypt(password, salt, 64, (err, key) => {
                if (!err && lib.timingSafeEqual(key, Buffer.from(secret, "base64"))) return callback();
                next();
            });
        },
    ], () => {
        callback({ status: 401, message: this.errInvalidSecret });
    });
}

// Load users from a JSON file, only add or update records
mod.loadFile = function(callback)
{
    if (!this.file) return;
    lib.readFile(this.file, { json: 1, logger: "error" }, (err, users) => {
        if (!err) {
            for (const p in users) {
                if (users[p].login && users[p].id && users[p].secret && users[p].name) {
                    this.users[users[p].login] = users[p];
                    logger.debug("loadFile:", mod.name, users[p]);
                }
            }
        }
        lib.tryCall(callback, err);
    });
}
