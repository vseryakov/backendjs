//
//  Author: Vlad Seryakov vseryakov@gmail.com
//  backendjs 2018
//

const util = require('util');
const logger = require(__dirname + '/../logger');
const lib = require(__dirname + '/../lib');
const xml2json = require("xml2json");

lib.unicodeAsciiMap = {
        "\u00AB": "\"", "\u00BB": "\"", "\u201C": "\"", "\u201D": "\"", "\u02BA": "\"", "\u02EE": "\"", "\u201F": "\"", "\u275D": "\"", "\u275E": "\"", "\u301D": "\"", "\u301E": "\"",
        "\uFF02": "\"", "\u2018": "'", "\u2019": "'", "\u02BB": "'", "\u02C8": "'", "\u02BC": "'", "\u02BD": "'", "\u02B9": "'", "\u201B": "'", "\uFF07": "'", "\u00B4": "'", "\u02CA": "'",
        "\u0060": "'", "\u02CB": "'", "\u275B": "'", "\u275C": "'", "\u0313": "'", "\u0314": "'", "\uFE10": "'", "\uFE11": "'", "\u00F7": "/", "\u00BC": "1/4", "\u00BD": "1/2", "\u00BE": "3/4",
        "\u29F8": "/", "\u0337": "/", "\u0338": "/", "\u2044": "/", "\u2215": "/", "\uFF0F": "/", "\u29F9": "\\", "\u29F5": "\\", "\u20E5": "\\", "\uFE68": "\\", "\uFF3C": "\\", "\u0332": "_",
        "\uFF3F": "_", "\u20D2": "|", "\u20D3": "|", "\u2223": "|", "\uFF5C": "|", "\u23B8": "|", "\u23B9": "|", "\u23D0": "|", "\u239C": "|", "\u239F": "|", "\u23BC": "-", "\u23BD": "-",
        "\u2015": "-", "\uFE63": "-", "\uFF0D": "-", "\u2010": "-", "\u2043": "-", "\uFE6B": "@", "\uFF20": "@", "\uFE69": "$", "\uFF04": "$", "\u01C3": "!", "\uFE15": "!", "\uFE57": "!",
        "\uFF01": "!", "\uFE5F": "#", "\uFF03": "#", "\uFE6A": "%", "\uFF05": "%", "\uFE60": "&", "\uFF06": "&", "\u201A": ", ", "\u0326": ", ", "\uFE50": ", ", "\uFE51": ", ", "\uFF0C": ", ",
        "\uFF64": ", ", "\u2768": "(", "\u276A": "(", "\uFE59": "(", "\uFF08": "(", "\u27EE": "(", "\u2985": "(", "\u2769": ")", "\u276B": ")", "\uFE5A": ")", "\uFF09": ")", "\u27EF": ")",
        "\u2986": ")", "\u204E": "*", "\u2217": "*", "\u229B": "*", "\u2722": "*", "\u2723": "*", "\u2724": "*", "\u2725": "*", "\u2731": "*", "\u2732": "*", "\u2733": "*", "\u273A": "*",
        "\u273B": "*", "\u273C": "*", "\u273D": "*", "\u2743": "*", "\u2749": "*", "\u274A": "*", "\u274B": "*", "\u29C6": "*", "\uFE61": "*", "\uFF0A": "*", "\u02D6": "+", "\uFE62": "+",
        "\uFF0B": "+", "\u3002": ".", "\uFE52": ".", "\uFF0E": ".", "\uFF61": ".", "\uFF10": "0", "\uFF11": "1", "\uFF12": "2", "\uFF13": "3", "\uFF14": "4", "\uFF15": "5", "\uFF16": "6",
        "\uFF17": "7", "\uFF18": "8", "\uFF19": "9", "\u02D0": ":", "\u02F8": ":", "\u2982": ":", "\uA789": ":", "\uFE13": ":", "\uFF1A": ":", "\u204F": ";", "\uFE14": ";", "\uFE54": ";",
        "\uFF1B": ";", "\uFE64": "<", "\uFF1C": "<", "\u0347": "=", "\uA78A": "=", "\uFE66": "=", "\uFF1D": "=", "\uFE65": ">", "\uFF1E": ">", "\uFE16": "?", "\uFE56": "?", "\uFF1F": "?",
        "\uFF21": "A", "\u1D00": "A", "\uFF22": "B", "\u0299": "B", "\uFF23": "C", "\u1D04": "C", "\uFF24": "D", "\u1D05": "D", "\uFF25": "E", "\u1D07": "E", "\uFF26": "F", "\uA730": "F",
        "\uFF27": "G", "\u0262": "G", "\uFF28": "H", "\u029C": "H", "\uFF29": "I", "\u026A": "I", "\uFF2A": "J", "\u1D0A": "J", "\uFF2B": "K", "\u1D0B": "K", "\uFF2C": "L", "\u029F": "L",
        "\uFF2D": "M", "\u1D0D": "M", "\uFF2E": "N", "\u0274": "N", "\uFF2F": "O", "\u1D0F": "O", "\uFF30": "P", "\u1D18": "P", "\uFF31": "Q", "\uFF32": "R", "\u0280": "R", "\uFF33": "S",
        "\uA731": "S", "\uFF34": "T", "\u1D1B": "T", "\uFF35": "U", "\u1D1C": "U", "\uFF36": "V", "\u1D20": "V", "\uFF37": "W", "\u1D21": "W", "\uFF38": "X", "\uFF39": "Y", "\u028F": "Y",
        "\uFF3A": "Z", "\u1D22": "Z", "\u02C6": "^", "\u0302": "^", "\uFF3E": "^", "\u1DCD": "^", "\u2774": "{", "\uFE5B": "{", "\uFF5B": "{", "\u2775": "}", "\uFE5C": "}", "\uFF5D": "}",
        "\uFF3B": "[", "\uFF3D": "]", "\u02DC": "~", "\u02F7": "~", "\u0303": "~", "\u0330": "~", "\u0334": "~", "\u223C": "~", "\uFF5E": "~", "\u00A0": "'", "\u2000": "'", "\u2001": " ",
        "\u2002": " ", "\u2003": " ", "\u2004": " ", "\u2005": " ", "\u2006": " ", "\u2007": " ", "\u2008": " ", "\u2009": " ", "\u200A": " ", "\u202F": " ", "\u205F": " ", "\u3000": " ", "\u008D": " ",
        "\u009F": " ", "\u0080": " ", "\u0090": " ", "\u009B": " ", "\u0010": " ", "\u0009": " ", "\u0000": " ", "\u0003": " ", "\u0004": " ", "\u0017": " ", "\u0019": " ", "\u0011": " ", "\u0012": " ",
        "\u0013": " ", "\u0014": " ", "\u2017": "_", "\u2014": "-", "\u2013": "-", "\u2039": ">", "\u203A": "<", "\u203C": "!!", "\u201E": "\"",
        "\u2026": "...", "\u2028": " ", "\u2029": " ", "\u2060": " ", "\u202C": " ",
};

lib.htmlEntities = {
        'AElig': '√Ü','AMP': '','Aacute': '√Å','Abreve': 'ƒÇ','Acirc': '√Ç',
        'Acy': '–ê','Afr': 'ùîÑ','Agrave': '√Ä','Alpha': 'Œë','Amacr': 'ƒÄ',
        'And': '‚©ì','Aogon': 'ƒÑ','Aopf': 'ùî∏','ApplyFunction': '','Aring': '√Ö',
        'Ascr': 'ùíú','Assign': '‚âî','Atilde': '√É','Auml': '√Ñ','Backslash': '‚àñ',
        'Barv': '‚´ß','Barwed': '‚åÜ','Bcy': '–ë','Because': '‚àµ','Bernoullis': '‚Ñ¨',
        'Beta': 'Œí','Bfr': 'ùîÖ','Bopf': 'ùîπ','Breve': 'Àò','Bscr': '‚Ñ¨',
        'Bumpeq': '‚âé','CHcy': '–ß','COPY': '¬©','Cacute': 'ƒÜ','Cap': '‚ãí',
        'CapitalDifferentialD': '‚ÖÖ','Cayleys': '‚Ñ≠','Ccaron': 'ƒå','Ccedil': '√á','Ccirc': 'ƒà',
        'Cconint': '‚à∞','Cdot': 'ƒä','Cedilla': '¬∏','CenterDot': '¬∑','Cfr': '‚Ñ≠',
        'Chi': 'Œß','CircleDot': '‚äô','CircleMinus': '‚äñ','CirclePlus': '‚äï','CircleTimes': '‚äó',
        'ClockwiseContourIntegral': '‚à≤','CloseCurlyDoubleQuote': '‚Äù','CloseCurlyQuote': '‚Äô','Colon': '‚à∑','Colone': '‚©¥',
        'Congruent': '‚â°','Conint': '‚àØ','ContourIntegral': '‚àÆ','Copf': '‚ÑÇ','Coproduct': '‚àê',
        'CounterClockwiseContourIntegral': '‚à≥','Cross': '‚®Ø','Cscr': 'ùíû','Cup': '‚ãì','CupCap': '‚âç',
        'DD': '‚ÖÖ','DDotrahd': '‚§ë','DJcy': '–Ç','DScy': '–Ö','DZcy': '–è',
        'Dagger': '‚Ä°','Darr': '‚Ü°','Dashv': '‚´§','Dcaron': 'ƒé','Dcy': '–î',
        'Del': '‚àá','Delta': 'Œî','Dfr': 'ùîá','DiacriticalAcute': '¬¥','DiacriticalDot': 'Àô',
        'DiacriticalDoubleAcute': 'Àù','DiacriticalGrave': '`','DiacriticalTilde': 'Àú','Diamond': '‚ãÑ','DifferentialD': '‚ÖÜ',
        'Dopf': 'ùîª','Dot': '¬®','DotDot': '‚Éú','DotEqual': '‚âê','DoubleContourIntegral': '‚àØ',
        'DoubleDot': '¬®','DoubleDownArrow': '‚áì','DoubleLeftArrow': '‚áê','DoubleLeftRightArrow': '‚áî','DoubleLeftTee': '‚´§',
        'DoubleLongLeftArrow': '‚ü∏','DoubleLongLeftRightArrow': '‚ü∫','DoubleLongRightArrow': '‚üπ','DoubleRightArrow': '‚áí','DoubleRightTee': '‚ä®',
        'DoubleUpArrow': '‚áë','DoubleUpDownArrow': '‚áï','DoubleVerticalBar': '‚à•','DownArrow': '‚Üì','DownArrowBar': '‚§ì',
        'DownArrowUpArrow': '‚áµ','DownBreve': 'Ãë','DownLeftRightVector': '‚•ê','DownLeftTeeVector': '‚•û','DownLeftVector': '‚ÜΩ',
        'DownLeftVectorBar': '‚•ñ','DownRightTeeVector': '‚•ü','DownRightVector': '‚áÅ','DownRightVectorBar': '‚•ó','DownTee': '‚ä§',
        'DownTeeArrow': '‚Üß','Downarrow': '‚áì','Dscr': 'ùíü','Dstrok': 'ƒê','ENG': '≈ä',
        'ETH': '√ê','Eacute': '√â','Ecaron': 'ƒö','Ecirc': '√ä','Ecy': '–≠',
        'Edot': 'ƒñ','Efr': 'ùîà','Egrave': '√à','Element': '‚àà','Emacr': 'ƒí',
        'EmptySmallSquare': '‚óª','EmptyVerySmallSquare': '‚ñ´','Eogon': 'ƒò','Eopf': 'ùîº','Epsilon': 'Œï',
        'Equal': '‚©µ','EqualTilde': '‚âÇ','Equilibrium': '‚áå','Escr': '‚Ñ∞','Esim': '‚©≥',
        'Eta': 'Œó','Euml': '√ã','Exists': '‚àÉ','ExponentialE': '‚Öá','Fcy': '–§',
        'Ffr': 'ùîâ','FilledSmallSquare': '‚óº','FilledVerySmallSquare': '‚ñ™','Fopf': 'ùîΩ','ForAll': '‚àÄ',
        'Fouriertrf': '‚Ñ±','Fscr': '‚Ñ±','GJcy': '–É','GT': '>','Gamma': 'Œì',
        'Gammad': 'œú','Gbreve': 'ƒû','Gcedil': 'ƒ¢','Gcirc': 'ƒú','Gcy': '–ì',
        'Gdot': 'ƒ†','Gfr': 'ùîä','Gg': '‚ãô','Gopf': 'ùîæ','GreaterEqual': '‚â•',
        'GreaterEqualLess': '‚ãõ','GreaterFullEqual': '‚âß','GreaterGreater': '‚™¢','GreaterLess': '‚â∑','GreaterSlantEqual': '‚©æ',
        'GreaterTilde': '‚â≥','Gscr': 'ùí¢','Gt': '‚â´','HARDcy': '–™','Hacek': 'Àá',
        'Hat': '^','Hcirc': 'ƒ§','Hfr': '‚Ñå','HilbertSpace': '‚Ñã','Hopf': '‚Ñç',
        'HorizontalLine': '‚îÄ','Hscr': '‚Ñã','Hstrok': 'ƒ¶','HumpDownHump': '‚âé','HumpEqual': '‚âè',
        'IEcy': '–ï','IJlig': 'ƒ≤','IOcy': '–Å','Iacute': '√ç','Icirc': '√é',
        'Icy': '–ò','Idot': 'ƒ∞','Ifr': '‚Ñë','Igrave': '√å','Im': '‚Ñë',
        'Imacr': 'ƒ™','ImaginaryI': '‚Öà','Implies': '‚áí','Int': '‚à¨','Integral': '‚à´',
        'Intersection': '‚ãÇ','InvisibleComma': '','InvisibleTimes': '','Iogon': 'ƒÆ','Iopf': 'ùïÄ',
        'Iota': 'Œô','Iscr': '‚Ñê','Itilde': 'ƒ®','Iukcy': '–Ü','Iuml': '√è',
        'Jcirc': 'ƒ¥','Jcy': '–ô','Jfr': 'ùîç','Jopf': 'ùïÅ','Jscr': 'ùí•',
        'Jsercy': '–à','Jukcy': '–Ñ','KHcy': '–•','KJcy': '–å','Kappa': 'Œö',
        'Kcedil': 'ƒ∂','Kcy': '–ö','Kfr': 'ùîé','Kopf': 'ùïÇ','Kscr': 'ùí¶',
        'LJcy': '–â','LT': '<','Lacute': 'ƒπ','Lambda': 'Œõ','Lang': '‚ü™',
        'Laplacetrf': '‚Ñí','Larr': '‚Üû','Lcaron': 'ƒΩ','Lcedil': 'ƒª','Lcy': '–õ',
        'LeftAngleBracket': '‚ü®','LeftArrow': '‚Üê','LeftArrowBar': '‚á§','LeftArrowRightArrow': '‚áÜ','LeftCeiling': '‚åà',
        'LeftDoubleBracket': '‚ü¶','LeftDownTeeVector': '‚•°','LeftDownVector': '‚áÉ','LeftDownVectorBar': '‚•ô','LeftFloor': '‚åä',
        'LeftRightArrow': '‚Üî','LeftRightVector': '‚•é','LeftTee': '‚ä£','LeftTeeArrow': '‚Ü§','LeftTeeVector': '‚•ö',
        'LeftTriangle': '‚ä≤','LeftTriangleBar': '‚ßè','LeftTriangleEqual': '‚ä¥','LeftUpDownVector': '‚•ë','LeftUpTeeVector': '‚•†',
        'LeftUpVector': '‚Üø','LeftUpVectorBar': '‚•ò','LeftVector': '‚Üº','LeftVectorBar': '‚•í','Leftarrow': '‚áê',
        'Leftrightarrow': '‚áî','LessEqualGreater': '‚ãö','LessFullEqual': '‚â¶','LessGreater': '‚â∂','LessLess': '‚™°',
        'LessSlantEqual': '‚©Ω','LessTilde': '‚â≤','Lfr': 'ùîè','Ll': '‚ãò','Lleftarrow': '‚áö',
        'Lmidot': 'ƒø','LongLeftArrow': '‚üµ','LongLeftRightArrow': '‚ü∑','LongRightArrow': '‚ü∂','Longleftarrow': '‚ü∏',
        'Longleftrightarrow': '‚ü∫','Longrightarrow': '‚üπ','Lopf': 'ùïÉ','LowerLeftArrow': '‚Üô','LowerRightArrow': '‚Üò',
        'Lscr': '‚Ñí','Lsh': '‚Ü∞','Lstrok': '≈Å','Lt': '‚â™','Map': '‚§Ö',
        'Mcy': '–ú','MediumSpace': '‚Åü','Mellintrf': '‚Ñ≥','Mfr': 'ùîê','MinusPlus': '‚àì',
        'Mopf': 'ùïÑ','Mscr': '‚Ñ≥','Mu': 'Œú','NJcy': '–ä','Nacute': '≈É',
        'Ncaron': '≈á','Ncedil': '≈Ö','Ncy': '–ù','NegativeMediumSpace': '','NegativeThickSpace': '',
        'NegativeThinSpace': '','NegativeVeryThinSpace': '','NestedGreaterGreater': '‚â´','NestedLessLess': '‚â™','NewLine': '\n',
        'Nfr': 'ùîë','NoBreak': '','NonBreakingSpace': '¬†','Nopf': '‚Ñï','Not': '‚´¨',
        'NotCongruent': '‚â¢','NotCupCap': '‚â≠','NotDoubleVerticalBar': '‚à¶','NotElement': '‚àâ','NotEqual': '‚â†',
        'NotEqualTilde': '‚âÇÃ∏','NotExists': '‚àÑ','NotGreater': '‚âØ','NotGreaterEqual': '‚â±','NotGreaterFullEqual': '‚âßÃ∏',
        'NotGreaterGreater': '‚â´Ã∏','NotGreaterLess': '‚âπ','NotGreaterSlantEqual': '‚©æÃ∏','NotGreaterTilde': '‚âµ','NotHumpDownHump': '‚âéÃ∏',
        'NotHumpEqual': '‚âèÃ∏','NotLeftTriangle': '‚ã™','NotLeftTriangleBar': '‚ßèÃ∏','NotLeftTriangleEqual': '‚ã¨','NotLess': '‚âÆ',
        'NotLessEqual': '‚â∞','NotLessGreater': '‚â∏','NotLessLess': '‚â™Ã∏','NotLessSlantEqual': '‚©ΩÃ∏','NotLessTilde': '‚â¥',
        'NotNestedGreaterGreater': '‚™¢Ã∏','NotNestedLessLess': '‚™°Ã∏','NotPrecedes': '‚äÄ','NotPrecedesEqual': '‚™ØÃ∏','NotPrecedesSlantEqual': '‚ã†',
        'NotReverseElement': '‚àå','NotRightTriangle': '‚ã´','NotRightTriangleBar': '‚ßêÃ∏','NotRightTriangleEqual': '‚ã≠','NotSquareSubset': '‚äèÃ∏',
        'NotSquareSubsetEqual': '‚ã¢','NotSquareSuperset': '‚äêÃ∏','NotSquareSupersetEqual': '‚ã£','NotSubset': '‚äÇ‚Éí','NotSubsetEqual': '‚äà',
        'NotSucceeds': '‚äÅ','NotSucceedsEqual': '‚™∞Ã∏','NotSucceedsSlantEqual': '‚ã°','NotSucceedsTilde': '‚âøÃ∏','NotSuperset': '‚äÉ‚Éí',
        'NotSupersetEqual': '‚äâ','NotTilde': '‚âÅ','NotTildeEqual': '‚âÑ','NotTildeFullEqual': '‚âá','NotTildeTilde': '‚ââ',
        'NotVerticalBar': '‚à§','Nscr': 'ùí©','Ntilde': '√ë','Nu': 'Œù','OElig': '≈í',
        'Oacute': '√ì','Ocirc': '√î','Ocy': '–û','Odblac': '≈ê','Ofr': 'ùîí',
        'Ograve': '√í','Omacr': '≈å','Omega': 'Œ©','Omicron': 'Œü','Oopf': 'ùïÜ',
        'OpenCurlyDoubleQuote': '‚Äú','OpenCurlyQuote': '‚Äò','Or': '‚©î','Oscr': 'ùí™','Oslash': '√ò',
        'Otilde': '√ï','Otimes': '‚®∑','Ouml': '√ñ','OverBar': '‚Äæ','OverBrace': '‚èû',
        'OverBracket': '‚é¥','OverParenthesis': '‚èú','PartialD': '‚àÇ','Pcy': '–ü','Pfr': 'ùîì',
        'Phi': 'Œ¶','Pi': 'Œ†','PlusMinus': '¬±','Poincareplane': '‚Ñå','Popf': '‚Ñô',
        'Pr': '‚™ª','Precedes': '‚â∫','PrecedesEqual': '‚™Ø','PrecedesSlantEqual': '‚âº','PrecedesTilde': '‚âæ',
        'Prime': '‚Ä≥','Product': '‚àè','Proportion': '‚à∑','Proportional': '‚àù','Pscr': 'ùí´',
        'Psi': 'Œ®','QUOT': '"','Qfr': 'ùîî','Qopf': '‚Ñö','Qscr': 'ùí¨',
        'RBarr': '‚§ê','REG': '¬Æ','Racute': '≈î','Rang': '‚ü´','Rarr': '‚Ü†',
        'Rarrtl': '‚§ñ','Rcaron': '≈ò','Rcedil': '≈ñ','Rcy': '–†','Re': '‚Ñú',
        'ReverseElement': '‚àã','ReverseEquilibrium': '‚áã','ReverseUpEquilibrium': '‚•Ø','Rfr': '‚Ñú','Rho': 'Œ°',
        'RightAngleBracket': '‚ü©','RightArrow': '‚Üí','RightArrowBar': '‚á•','RightArrowLeftArrow': '‚áÑ','RightCeiling': '‚åâ',
        'RightDoubleBracket': '‚üß','RightDownTeeVector': '‚•ù','RightDownVector': '‚áÇ','RightDownVectorBar': '‚•ï','RightFloor': '‚åã',
        'RightTee': '‚ä¢','RightTeeArrow': '‚Ü¶','RightTeeVector': '‚•õ','RightTriangle': '‚ä≥','RightTriangleBar': '‚ßê',
        'RightTriangleEqual': '‚äµ','RightUpDownVector': '‚•è','RightUpTeeVector': '‚•ú','RightUpVector': '‚Üæ','RightUpVectorBar': '‚•î',
        'RightVector': '‚áÄ','RightVectorBar': '‚•ì','Rightarrow': '‚áí','Ropf': '‚Ñù','RoundImplies': '‚•∞',
        'Rrightarrow': '‚áõ','Rscr': '‚Ñõ','Rsh': '‚Ü±','RuleDelayed': '‚ß¥','SHCHcy': '–©',
        'SHcy': '–®','SOFTcy': '–¨','Sacute': '≈ö','Sc': '‚™º','Scaron': '≈†',
        'Scedil': '≈û','Scirc': '≈ú','Scy': '–°','Sfr': 'ùîñ','ShortDownArrow': '‚Üì',
        'ShortLeftArrow': '‚Üê','ShortRightArrow': '‚Üí','ShortUpArrow': '‚Üë','Sigma': 'Œ£','SmallCircle': '‚àò',
        'Sopf': 'ùïä','Sqrt': '‚àö','Square': '‚ñ°','SquareIntersection': '‚äì','SquareSubset': '‚äè',
        'SquareSubsetEqual': '‚äë','SquareSuperset': '‚äê','SquareSupersetEqual': '‚äí','SquareUnion': '‚äî','Sscr': 'ùíÆ',
        'Star': '‚ãÜ','Sub': '‚ãê','Subset': '‚ãê','SubsetEqual': '‚äÜ','Succeeds': '‚âª',
        'SucceedsEqual': '‚™∞','SucceedsSlantEqual': '‚âΩ','SucceedsTilde': '‚âø','SuchThat': '‚àã','Sum': '‚àë',
        'Sup': '‚ãë','Superset': '‚äÉ','SupersetEqual': '‚äá','Supset': '‚ãë','THORN': '√û',
        'TRADE': '‚Ñ¢','TSHcy': '–ã','TScy': '–¶','Tab': '  ','Tau': 'Œ§',
        'Tcaron': '≈§','Tcedil': '≈¢','Tcy': '–¢','Tfr': 'ùîó','Therefore': '‚à¥',
        'Theta': 'Œò','ThickSpace': '‚Åü‚Ää','ThinSpace': '‚Äâ','Tilde': '‚àº','TildeEqual': '‚âÉ',
        'TildeFullEqual': '‚âÖ','TildeTilde': '‚âà','Topf': 'ùïã','TripleDot': '‚Éõ','Tscr': 'ùíØ',
        'Tstrok': '≈¶','Uacute': '√ö','Uarr': '‚Üü','Uarrocir': '‚•â','Ubrcy': '–é',
        'Ubreve': '≈¨','Ucirc': '√õ','Ucy': '–£','Udblac': '≈∞','Ufr': 'ùîò',
        'Ugrave': '√ô','Umacr': '≈™','UnderBar': '_','UnderBrace': '‚èü','UnderBracket': '‚éµ',
        'UnderParenthesis': '‚èù','Union': '‚ãÉ','UnionPlus': '‚äé','Uogon': '≈≤','Uopf': 'ùïå',
        'UpArrow': '‚Üë','UpArrowBar': '‚§í','UpArrowDownArrow': '‚áÖ','UpDownArrow': '‚Üï','UpEquilibrium': '‚•Æ',
        'UpTee': '‚ä•','UpTeeArrow': '‚Ü•','Uparrow': '‚áë','Updownarrow': '‚áï','UpperLeftArrow': '‚Üñ',
        'UpperRightArrow': '‚Üó','Upsi': 'œí','Upsilon': 'Œ•','Uring': '≈Æ','Uscr': 'ùí∞',
        'Utilde': '≈®','Uuml': '√ú','VDash': '‚ä´','Vbar': '‚´´','Vcy': '–í',
        'Vdash': '‚ä©','Vdashl': '‚´¶','Vee': '‚ãÅ','Verbar': '‚Äñ','Vert': '‚Äñ',
        'VerticalBar': '‚à£','VerticalLine': '|','VerticalSeparator': '‚ùò','VerticalTilde': '‚âÄ','VeryThinSpace': '‚Ää',
        'Vfr': 'ùîô','Vopf': 'ùïç','Vscr': 'ùí±','Vvdash': '‚ä™','Wcirc': '≈¥',
        'Wedge': '‚ãÄ','Wfr': 'ùîö','Wopf': 'ùïé','Wscr': 'ùí≤','Xfr': 'ùîõ',
        'Xi': 'Œû','Xopf': 'ùïè','Xscr': 'ùí≥','YAcy': '–Ø','YIcy': '–á',
        'YUcy': '–Æ','Yacute': '√ù','Ycirc': '≈∂','Ycy': '–´','Yfr': 'ùîú',
        'Yopf': 'ùïê','Yscr': 'ùí¥','Yuml': '≈∏','ZHcy': '–ñ','Zacute': '≈π',
        'Zcaron': '≈Ω','Zcy': '–ó','Zdot': '≈ª','ZeroWidthSpace': '','Zeta': 'Œñ',
        'Zfr': '‚Ñ®','Zopf': '‚Ñ§','Zscr': 'ùíµ','aacute': '√°','abreve': 'ƒÉ',
        'ac': '‚àæ','acE': '‚àæÃ≥','acd': '‚àø','acirc': '√¢','acute': '¬¥',
        'acy': '–∞','aelig': '√¶','af': '','afr': 'ùîû','agrave': '√†',
        'alefsym': '‚Ñµ','aleph': '‚Ñµ','alpha': 'Œ±','amacr': 'ƒÅ','amalg': '‚®ø',
        'amp': '','and': '‚àß','andand': '‚©ï','andd': '‚©ú','andslope': '‚©ò',
        'andv': '‚©ö','ang': '‚à†','ange': '‚¶§','angle': '‚à†','angmsd': '‚à°',
        'angmsdaa': '‚¶®','angmsdab': '‚¶©','angmsdac': '‚¶™','angmsdad': '‚¶´','angmsdae': '‚¶¨',
        'angmsdaf': '‚¶≠','angmsdag': '‚¶Æ','angmsdah': '‚¶Ø','angrt': '‚àü','angrtvb': '‚äæ',
        'angrtvbd': '‚¶ù','angsph': '‚à¢','angst': '√Ö','angzarr': '‚çº','aogon': 'ƒÖ',
        'aopf': 'ùïí','ap': '‚âà','apE': '‚©∞','apacir': '‚©Ø','ape': '‚âä',
        'apid': '‚âã','apos': "'",'approx': '‚âà','approxeq': '‚âä','aring': '√•',
        'ascr': 'ùí∂','ast': '*','asymp': '‚âà','asympeq': '‚âç','atilde': '√£',
        'auml': '√§','awconint': '‚à≥','awint': '‚®ë','bNot': '‚´≠','backcong': '‚âå',
        'backepsilon': 'œ∂','backprime': '‚Äµ','backsim': '‚àΩ','backsimeq': '‚ãç','barvee': '‚äΩ',
        'barwed': '‚åÖ','barwedge': '‚åÖ','bbrk': '‚éµ','bbrktbrk': '‚é∂','bcong': '‚âå',
        'bcy': '–±','bdquo': '‚Äû','becaus': '‚àµ','because': '‚àµ','bemptyv': '‚¶∞',
        'bepsi': 'œ∂','bernou': '‚Ñ¨','beta': 'Œ≤','beth': '‚Ñ∂','between': '‚â¨',
        'bfr': 'ùîü','bigcap': '‚ãÇ','bigcirc': '‚óØ','bigcup': '‚ãÉ','bigodot': '‚®Ä',
        'bigoplus': '‚®Å','bigotimes': '‚®Ç','bigsqcup': '‚®Ü','bigstar': '‚òÖ','bigtriangledown': '‚ñΩ',
        'bigtriangleup': '‚ñ≥','biguplus': '‚®Ñ','bigvee': '‚ãÅ','bigwedge': '‚ãÄ','bkarow': '‚§ç',
        'blacklozenge': '‚ß´','blacksquare': '‚ñ™','blacktriangle': '‚ñ¥','blacktriangledown': '‚ñæ','blacktriangleleft': '‚óÇ',
        'blacktriangleright': '‚ñ∏','blank': '‚ê£','blk12': '‚ñí','blk14': '‚ñë','blk34': '‚ñì',
        'block': '‚ñà','bne': '=‚É•','bnequiv': '‚â°‚É•','bnot': '‚åê','bopf': 'ùïì',
        'bot': '‚ä•','bottom': '‚ä•','bowtie': '‚ãà','boxDL': '‚ïó','boxDR': '‚ïî',
        'boxDl': '‚ïñ','boxDr': '‚ïì','boxH': '‚ïê','boxHD': '‚ï¶','boxHU': '‚ï©',
        'boxHd': '‚ï§','boxHu': '‚ïß','boxUL': '‚ïù','boxUR': '‚ïö','boxUl': '‚ïú',
        'boxUr': '‚ïô','boxV': '‚ïë','boxVH': '‚ï¨','boxVL': '‚ï£','boxVR': '‚ï†',
        'boxVh': '‚ï´','boxVl': '‚ï¢','boxVr': '‚ïü','boxbox': '‚ßâ','boxdL': '‚ïï',
        'boxdR': '‚ïí','boxdl': '‚îê','boxdr': '‚îå','boxh': '‚îÄ','boxhD': '‚ï•',
        'boxhU': '‚ï®','boxhd': '‚î¨','boxhu': '‚î¥','boxminus': '‚äü','boxplus': '‚äû',
        'boxtimes': '‚ä†','boxuL': '‚ïõ','boxuR': '‚ïò','boxul': '‚îò','boxur': '‚îî',
        'boxv': '‚îÇ','boxvH': '‚ï™','boxvL': '‚ï°','boxvR': '‚ïû','boxvh': '‚îº',
        'boxvl': '‚î§','boxvr': '‚îú','bprime': '‚Äµ','breve': 'Àò','brvbar': '¬¶',
        'bscr': 'ùí∑','bsemi': '‚Åè','bsim': '‚àΩ','bsime': '‚ãç','bsol': '\\',
        'bsolb': '‚ßÖ','bsolhsub': '‚üà','bull': '‚Ä¢','bullet': '‚Ä¢','bump': '‚âé',
        'bumpE': '‚™Æ','bumpe': '‚âè','bumpeq': '‚âè','cacute': 'ƒá','cap': '‚à©',
        'capand': '‚©Ñ','capbrcup': '‚©â','capcap': '‚©ã','capcup': '‚©á','capdot': '‚©Ä',
        'caps': '‚à©Ô∏Ä','caret': '‚ÅÅ','caron': 'Àá','ccaps': '‚©ç','ccaron': 'ƒç',
        'ccedil': '√ß','ccirc': 'ƒâ','ccups': '‚©å','ccupssm': '‚©ê','cdot': 'ƒã',
        'cedil': '¬∏','cemptyv': '‚¶≤','cent': '¬¢','centerdot': '¬∑','cfr': 'ùî†',
        'chcy': '—á','check': '‚úì','checkmark': '‚úì','chi': 'œá','cir': '‚óã',
        'cirE': '‚ßÉ','circ': 'ÀÜ','circeq': '‚âó','circlearrowleft': '‚Ü∫','circlearrowright': '‚Üª',
        'circledR': '¬Æ','circledS': '‚ìà','circledast': '‚äõ','circledcirc': '‚äö','circleddash': '‚äù',
        'cire': '‚âó','cirfnint': '‚®ê','cirmid': '‚´Ø','cirscir': '‚ßÇ','clubs': '‚ô£',
        'clubsuit': '‚ô£','colon': ':','colone': '‚âî','coloneq': '‚âî','comma': ',',
        'commat': '@','comp': '‚àÅ','compfn': '‚àò','complement': '‚àÅ','complexes': '‚ÑÇ',
        'cong': '‚âÖ','congdot': '‚©≠','conint': '‚àÆ','copf': 'ùïî','coprod': '‚àê',
        'copy': '¬©','copysr': '‚Ñó','crarr': '‚Üµ','cross': '‚úó','cscr': 'ùí∏',
        'csub': '‚´è','csube': '‚´ë','csup': '‚´ê','csupe': '‚´í','ctdot': '‚ãØ',
        'cudarrl': '‚§∏','cudarrr': '‚§µ','cuepr': '‚ãû','cuesc': '‚ãü','cularr': '‚Ü∂',
        'cularrp': '‚§Ω','cup': '‚à™','cupbrcap': '‚©à','cupcap': '‚©Ü','cupcup': '‚©ä',
        'cupdot': '‚äç','cupor': '‚©Ö','cups': '‚à™Ô∏Ä','curarr': '‚Ü∑','curarrm': '‚§º',
        'curlyeqprec': '‚ãû','curlyeqsucc': '‚ãü','curlyvee': '‚ãé','curlywedge': '‚ãè','curren': '¬§',
        'curvearrowleft': '‚Ü∂','curvearrowright': '‚Ü∑','cuvee': '‚ãé','cuwed': '‚ãè','cwconint': '‚à≤',
        'cwint': '‚à±','cylcty': '‚å≠','dArr': '‚áì','dHar': '‚••','dagger': '‚Ä†',
        'daleth': '‚Ñ∏','darr': '‚Üì','dash': '‚Äê','dashv': '‚ä£','dbkarow': '‚§è',
        'dblac': 'Àù','dcaron': 'ƒè','dcy': '–¥','dd': '‚ÖÜ','ddagger': '‚Ä°',
        'ddarr': '‚áä','ddotseq': '‚©∑','deg': '¬∞','delta': 'Œ¥','demptyv': '‚¶±',
        'dfisht': '‚•ø','dfr': 'ùî°','dharl': '‚áÉ','dharr': '‚áÇ','diam': '‚ãÑ',
        'diamond': '‚ãÑ','diamondsuit': '‚ô¶','diams': '‚ô¶','die': '¬®','digamma': 'œù',
        'disin': '‚ã≤','div': '√∑','divide': '√∑','divideontimes': '‚ãá','divonx': '‚ãá',
        'djcy': '—í','dlcorn': '‚åû','dlcrop': '‚åç','dollar': '$','dopf': 'ùïï',
        'dot': 'Àô','doteq': '‚âê','doteqdot': '‚âë','dotminus': '‚à∏','dotplus': '‚àî',
        'dotsquare': '‚ä°','doublebarwedge': '‚åÜ','downarrow': '‚Üì','downdownarrows': '‚áä','downharpoonleft': '‚áÉ',
        'downharpoonright': '‚áÇ','drbkarow': '‚§ê','drcorn': '‚åü','drcrop': '‚åå','dscr': 'ùíπ',
        'dscy': '—ï','dsol': '‚ß∂','dstrok': 'ƒë','dtdot': '‚ã±','dtri': '‚ñø',
        'dtrif': '‚ñæ','duarr': '‚áµ','duhar': '‚•Ø','dwangle': '‚¶¶','dzcy': '—ü',
        'dzigrarr': '‚üø','eDDot': '‚©∑','eDot': '‚âë','eacute': '√©','easter': '‚©Æ',
        'ecaron': 'ƒõ','ecir': '‚âñ','ecirc': '√™','ecolon': '‚âï','ecy': '—ç',
        'edot': 'ƒó','ee': '‚Öá','efDot': '‚âí','efr': 'ùî¢','eg': '‚™ö',
        'egrave': '√®','egs': '‚™ñ','egsdot': '‚™ò','el': '‚™ô','elinters': '‚èß',
        'ell': '‚Ñì','els': '‚™ï','elsdot': '‚™ó','emacr': 'ƒì','empty': '‚àÖ',
        'emptyset': '‚àÖ','emptyv': '‚àÖ','emsp13': '‚ÄÑ','emsp14': '‚ÄÖ','emsp': '‚ÄÉ',
        'eng': '≈ã','ensp': '‚ÄÇ','eogon': 'ƒô','eopf': 'ùïñ','epar': '‚ãï',
        'eparsl': '‚ß£','eplus': '‚©±','epsi': 'Œµ','epsilon': 'Œµ','epsiv': 'œµ',
        'eqcirc': '‚âñ','eqcolon': '‚âï','eqsim': '‚âÇ','eqslantgtr': '‚™ñ','eqslantless': '‚™ï',
        'equals': '=','equest': '‚âü','equiv': '‚â°','equivDD': '‚©∏','eqvparsl': '‚ß•',
        'erDot': '‚âì','erarr': '‚•±','escr': '‚ÑØ','esdot': '‚âê','esim': '‚âÇ',
        'eta': 'Œ∑','eth': '√∞','euml': '√´','euro': '‚Ç¨','excl': '!',
        'exist': '‚àÉ','expectation': '‚Ñ∞','exponentiale': '‚Öá','fallingdotseq': '‚âí','fcy': '—Ñ',
        'female': '‚ôÄ','ffilig': 'Ô¨É','fflig': 'Ô¨Ä','ffllig': 'Ô¨Ñ','ffr': 'ùî£',
        'filig': 'Ô¨Å','fjlig': 'fj','flat': '‚ô≠','fllig': 'Ô¨Ç','fltns': '‚ñ±',
        'fnof': '∆í','fopf': 'ùïó','forall': '‚àÄ','fork': '‚ãî','forkv': '‚´ô',
        'fpartint': '‚®ç','frac12': '¬Ω','frac13': '‚Öì','frac14': '¬º','frac15': '‚Öï',
        'frac16': '‚Öô','frac18': '‚Öõ','frac23': '‚Öî','frac25': '‚Öñ','frac34': '¬æ',
        'frac35': '‚Öó','frac38': '‚Öú','frac45': '‚Öò','frac56': '‚Öö','frac58': '‚Öù',
        'frac78': '‚Öû','frasl': '‚ÅÑ','frown': '‚å¢','fscr': 'ùíª','gE': '‚âß',
        'gEl': '‚™å','gacute': '«µ','gamma': 'Œ≥','gammad': 'œù','gap': '‚™Ü',
        'gbreve': 'ƒü','gcirc': 'ƒù','gcy': '–≥','gdot': 'ƒ°','ge': '‚â•',
        'gel': '‚ãõ','geq': '‚â•','geqq': '‚âß','geqslant': '‚©æ','ges': '‚©æ',
        'gescc': '‚™©','gesdot': '‚™Ä','gesdoto': '‚™Ç','gesdotol': '‚™Ñ','gesl': '‚ãõÔ∏Ä',
        'gesles': '‚™î','gfr': 'ùî§','gg': '‚â´','ggg': '‚ãô','gimel': '‚Ñ∑',
        'gjcy': '—ì','gl': '‚â∑','glE': '‚™í','gla': '‚™•','glj': '‚™§',
        'gnE': '‚â©','gnap': '‚™ä','gnapprox': '‚™ä','gne': '‚™à','gneq': '‚™à',
        'gneqq': '‚â©','gnsim': '‚ãß','gopf': 'ùïò','grave': '`','gscr': '‚Ñä',
        'gsim': '‚â≥','gsime': '‚™é','gsiml': '‚™ê','gt': '>','gtcc': '‚™ß',
        'gtcir': '‚©∫','gtdot': '‚ãó','gtlPar': '‚¶ï','gtquest': '‚©º','gtrapprox': '‚™Ü',
        'gtrarr': '‚•∏','gtrdot': '‚ãó','gtreqless': '‚ãõ','gtreqqless': '‚™å','gtrless': '‚â∑',
        'gtrsim': '‚â≥','gvertneqq': '‚â©Ô∏Ä','gvnE': '‚â©Ô∏Ä','hArr': '‚áî','hairsp': '‚Ää',
        'half': '¬Ω','hamilt': '‚Ñã','hardcy': '—ä','harr': '‚Üî','harrcir': '‚•à',
        'harrw': '‚Ü≠','hbar': '‚Ñè','hcirc': 'ƒ•','hearts': '‚ô•','heartsuit': '‚ô•',
        'hellip': '‚Ä¶','hercon': '‚äπ','hfr': 'ùî•','hksearow': '‚§•','hkswarow': '‚§¶',
        'hoarr': '‚áø','homtht': '‚àª','hookleftarrow': '‚Ü©','hookrightarrow': '‚Ü™','hopf': 'ùïô',
        'horbar': '‚Äï','hscr': 'ùíΩ','hslash': '‚Ñè','hstrok': 'ƒß','hybull': '‚ÅÉ',
        'hyphen': '‚Äê','iacute': '√≠','ic': '','icirc': '√Æ','icy': '–∏',
        'iecy': '–µ','iexcl': '¬°','iff': '‚áî','ifr': 'ùî¶','igrave': '√¨',
        'ii': '‚Öà','iiiint': '‚®å','iiint': '‚à≠','iinfin': '‚ßú','iiota': '‚Ñ©',
        'ijlig': 'ƒ≥','imacr': 'ƒ´','image': '‚Ñë','imagline': '‚Ñê','imagpart': '‚Ñë',
        'imath': 'ƒ±','imof': '‚ä∑','imped': '∆µ','in': '‚àà','incare': '‚ÑÖ',
        'infin': '‚àû','infintie': '‚ßù','inodot': 'ƒ±','int': '‚à´','intcal': '‚ä∫',
        'integers': '‚Ñ§','intercal': '‚ä∫','intlarhk': '‚®ó','intprod': '‚®º','iocy': '—ë',
        'iogon': 'ƒØ','iopf': 'ùïö','iota': 'Œπ','iprod': '‚®º','iquest': '¬ø',
        'iscr': 'ùíæ','isin': '‚àà','isinE': '‚ãπ','isindot': '‚ãµ','isins': '‚ã¥',
        'isinsv': '‚ã≥','isinv': '‚àà','it': '','itilde': 'ƒ©','iukcy': '—ñ',
        'iuml': '√Ø','jcirc': 'ƒµ','jcy': '–π','jfr': 'ùîß','jmath': '»∑',
        'jopf': 'ùïõ','jscr': 'ùíø','jsercy': '—ò','jukcy': '—î','kappa': 'Œ∫',
        'kappav': 'œ∞','kcedil': 'ƒ∑','kcy': '–∫','kfr': 'ùî®','kgreen': 'ƒ∏',
        'khcy': '—Ö','kjcy': '—ú','kopf': 'ùïú','kscr': 'ùìÄ','lAarr': '‚áö',
        'lArr': '‚áê','lAtail': '‚§õ','lBarr': '‚§é','lE': '‚â¶','lEg': '‚™ã',
        'lHar': '‚•¢','lacute': 'ƒ∫','laemptyv': '‚¶¥','lagran': '‚Ñí','lambda': 'Œª',
        'lang': '‚ü®','langd': '‚¶ë','langle': '‚ü®','lap': '‚™Ö','laquo': '¬´',
        'larr': '‚Üê','larrb': '‚á§','larrbfs': '‚§ü','larrfs': '‚§ù','larrhk': '‚Ü©',
        'larrlp': '‚Ü´','larrpl': '‚§π','larrsim': '‚•≥','larrtl': '‚Ü¢','lat': '‚™´',
        'latail': '‚§ô','late': '‚™≠','lates': '‚™≠Ô∏Ä','lbarr': '‚§å','lbbrk': '‚ù≤',
        'lbrace': '{','lbrack': '[','lbrke': '‚¶ã','lbrksld': '‚¶è','lbrkslu': '‚¶ç',
        'lcaron': 'ƒæ','lcedil': 'ƒº','lceil': '‚åà','lcub': '{','lcy': '–ª',
        'ldca': '‚§∂','ldquo': '‚Äú','ldquor': '‚Äû','ldrdhar': '‚•ß','ldrushar': '‚•ã',
        'ldsh': '‚Ü≤','le': '‚â§','leftarrow': '‚Üê','leftarrowtail': '‚Ü¢','leftharpoondown': '‚ÜΩ',
        'leftharpoonup': '‚Üº','leftleftarrows': '‚áá','leftrightarrow': '‚Üî','leftrightarrows': '‚áÜ','leftrightharpoons': '‚áã',
        'leftrightsquigarrow': '‚Ü≠','leftthreetimes': '‚ãã','leg': '‚ãö','leq': '‚â§','leqq': '‚â¶',
        'leqslant': '‚©Ω','les': '‚©Ω','lescc': '‚™®','lesdot': '‚©ø','lesdoto': '‚™Å',
        'lesdotor': '‚™É','lesg': '‚ãöÔ∏Ä','lesges': '‚™ì','lessapprox': '‚™Ö','lessdot': '‚ãñ',
        'lesseqgtr': '‚ãö','lesseqqgtr': '‚™ã','lessgtr': '‚â∂','lesssim': '‚â≤','lfisht': '‚•º',
        'lfloor': '‚åä','lfr': 'ùî©','lg': '‚â∂','lgE': '‚™ë','lhard': '‚ÜΩ',
        'lharu': '‚Üº','lharul': '‚•™','lhblk': '‚ñÑ','ljcy': '—ô','ll': '‚â™',
        'llarr': '‚áá','llcorner': '‚åû','llhard': '‚•´','lltri': '‚ó∫','lmidot': '≈Ä',
        'lmoust': '‚é∞','lmoustache': '‚é∞','lnE': '‚â®','lnap': '‚™â','lnapprox': '‚™â',
        'lne': '‚™á','lneq': '‚™á','lneqq': '‚â®','lnsim': '‚ã¶','loang': '‚ü¨',
        'loarr': '‚áΩ','lobrk': '‚ü¶','longleftarrow': '‚üµ','longleftrightarrow': '‚ü∑','longmapsto': '‚üº',
        'longrightarrow': '‚ü∂','looparrowleft': '‚Ü´','looparrowright': '‚Ü¨','lopar': '‚¶Ö','lopf': 'ùïù',
        'loplus': '‚®≠','lotimes': '‚®¥','lowast': '‚àó','lowbar': '_','loz': '‚óä',
        'lozenge': '‚óä','lozf': '‚ß´','lpar': '(','lparlt': '‚¶ì','lrarr': '‚áÜ',
        'lrcorner': '‚åü','lrhar': '‚áã','lrhard': '‚•≠','lrm': '','lrtri': '‚äø',
        'lsaquo': '‚Äπ','lscr': 'ùìÅ','lsh': '‚Ü∞','lsim': '‚â≤','lsime': '‚™ç',
        'lsimg': '‚™è','lsqb': '[','lsquo': '‚Äò','lsquor': '‚Äö','lstrok': '≈Ç',
        'lt': '<','ltcc': '‚™¶','ltcir': '‚©π','ltdot': '‚ãñ','lthree': '‚ãã',
        'ltimes': '‚ãâ','ltlarr': '‚•∂','ltquest': '‚©ª','ltrPar': '‚¶ñ','ltri': '‚óÉ',
        'ltrie': '‚ä¥','ltrif': '‚óÇ','lurdshar': '‚•ä','luruhar': '‚•¶','lvertneqq': '‚â®Ô∏Ä',
        'lvnE': '‚â®Ô∏Ä','mDDot': '‚à∫','macr': '¬Ø','male': '‚ôÇ','malt': '‚ú†',
        'maltese': '‚ú†','map': '‚Ü¶','mapsto': '‚Ü¶','mapstodown': '‚Üß','mapstoleft': '‚Ü§',
        'mapstoup': '‚Ü•','marker': '‚ñÆ','mcomma': '‚®©','mcy': '–º','mdash': '‚Äî',
        'measuredangle': '‚à°','mfr': 'ùî™','mho': '‚Ñß','micro': '¬µ','mid': '‚à£',
        'midast': '*','midcir': '‚´∞','middot': '¬∑','minus': '‚àí','minusb': '‚äü',
        'minusd': '‚à∏','minusdu': '‚®™','mlcp': '‚´õ','mldr': '‚Ä¶','mnplus': '‚àì',
        'models': '‚äß','mopf': 'ùïû','mp': '‚àì','mscr': 'ùìÇ','mstpos': '‚àæ',
        'mu': 'Œº','multimap': '‚ä∏','mumap': '‚ä∏','nGg': '‚ãôÃ∏','nGt': '‚â´‚Éí',
        'nGtv': '‚â´Ã∏','nLeftarrow': '‚áç','nLeftrightarrow': '‚áé','nLl': '‚ãòÃ∏','nLt': '‚â™‚Éí',
        'nLtv': '‚â™Ã∏','nRightarrow': '‚áè','nVDash': '‚äØ','nVdash': '‚äÆ','nabla': '‚àá',
        'nacute': '≈Ñ','nang': '‚à†‚Éí','nap': '‚ââ','napE': '‚©∞Ã∏','napid': '‚âãÃ∏',
        'napos': '≈â','napprox': '‚ââ','natur': '‚ôÆ','natural': '‚ôÆ','naturals': '‚Ñï',
        'nbsp': '¬†','nbump': '‚âéÃ∏','nbumpe': '‚âèÃ∏','ncap': '‚©É','ncaron': '≈à',
        'ncedil': '≈Ü','ncong': '‚âá','ncongdot': '‚©≠Ã∏','ncup': '‚©Ç','ncy': '–Ω',
        'ndash': '‚Äì','ne': '‚â†','neArr': '‚áó','nearhk': '‚§§','nearr': '‚Üó',
        'nearrow': '‚Üó','nedot': '‚âêÃ∏','nequiv': '‚â¢','nesear': '‚§®','nesim': '‚âÇÃ∏',
        'nexist': '‚àÑ','nexists': '‚àÑ','nfr': 'ùî´','ngE': '‚âßÃ∏','nge': '‚â±',
        'ngeq': '‚â±','ngeqq': '‚âßÃ∏','ngeqslant': '‚©æÃ∏','nges': '‚©æÃ∏','ngsim': '‚âµ',
        'ngt': '‚âØ','ngtr': '‚âØ','nhArr': '‚áé','nharr': '‚ÜÆ','nhpar': '‚´≤',
        'ni': '‚àã','nis': '‚ãº','nisd': '‚ã∫','niv': '‚àã','njcy': '—ö',
        'nlArr': '‚áç','nlE': '‚â¶Ã∏','nlarr': '‚Üö','nldr': '‚Ä•','nle': '‚â∞',
        'nleftarrow': '‚Üö','nleftrightarrow': '‚ÜÆ','nleq': '‚â∞','nleqq': '‚â¶Ã∏','nleqslant': '‚©ΩÃ∏',
        'nles': '‚©ΩÃ∏','nless': '‚âÆ','nlsim': '‚â¥','nlt': '‚âÆ','nltri': '‚ã™',
        'nltrie': '‚ã¨','nmid': '‚à§','nopf': 'ùïü','not': '¬¨','notin': '‚àâ',
        'notinE': '‚ãπÃ∏','notindot': '‚ãµÃ∏','notinva': '‚àâ','notinvb': '‚ã∑','notinvc': '‚ã∂',
        'notni': '‚àå','notniva': '‚àå','notnivb': '‚ãæ','notnivc': '‚ãΩ','npar': '‚à¶',
        'nparallel': '‚à¶','nparsl': '‚´Ω‚É•','npart': '‚àÇÃ∏','npolint': '‚®î','npr': '‚äÄ',
        'nprcue': '‚ã†','npre': '‚™ØÃ∏','nprec': '‚äÄ','npreceq': '‚™ØÃ∏','nrArr': '‚áè',
        'nrarr': '‚Üõ','nrarrc': '‚§≥Ã∏','nrarrw': '‚ÜùÃ∏','nrightarrow': '‚Üõ','nrtri': '‚ã´',
        'nrtrie': '‚ã≠','nsc': '‚äÅ','nsccue': '‚ã°','nsce': '‚™∞Ã∏','nscr': 'ùìÉ',
        'nshortmid': '‚à§','nshortparallel': '‚à¶','nsim': '‚âÅ','nsime': '‚âÑ','nsimeq': '‚âÑ',
        'nsmid': '‚à§','nspar': '‚à¶','nsqsube': '‚ã¢','nsqsupe': '‚ã£','nsub': '‚äÑ',
        'nsubE': '‚´ÖÃ∏','nsube': '‚äà','nsubset': '‚äÇ‚Éí','nsubseteq': '‚äà','nsubseteqq': '‚´ÖÃ∏',
        'nsucc': '‚äÅ','nsucceq': '‚™∞Ã∏','nsup': '‚äÖ','nsupE': '‚´ÜÃ∏','nsupe': '‚äâ',
        'nsupset': '‚äÉ‚Éí','nsupseteq': '‚äâ','nsupseteqq': '‚´ÜÃ∏','ntgl': '‚âπ','ntilde': '√±',
        'ntlg': '‚â∏','ntriangleleft': '‚ã™','ntrianglelefteq': '‚ã¨','ntriangleright': '‚ã´','ntrianglerighteq': '‚ã≠',
        'nu': 'ŒΩ','num': '#','numero': '‚Ññ','numsp': '‚Äá','nvDash': '‚ä≠',
        'nvHarr': '‚§Ñ','nvap': '‚âç‚Éí','nvdash': '‚ä¨','nvge': '‚â•‚Éí','nvgt': '>‚Éí',
        'nvinfin': '‚ßû','nvlArr': '‚§Ç','nvle': '‚â§‚Éí','nvlt': '<‚Éí','nvltrie': '‚ä¥‚Éí',
        'nvrArr': '‚§É','nvrtrie': '‚äµ‚Éí','nvsim': '‚àº‚Éí','nwArr': '‚áñ','nwarhk': '‚§£',
        'nwarr': '‚Üñ','nwarrow': '‚Üñ','nwnear': '‚§ß','oS': '‚ìà','oacute': '√≥',
        'oast': '‚äõ','ocir': '‚äö','ocirc': '√¥','ocy': '–æ','odash': '‚äù',
        'odblac': '≈ë','odiv': '‚®∏','odot': '‚äô','odsold': '‚¶º','oelig': '≈ì',
        'ofcir': '‚¶ø','ofr': 'ùî¨','ogon': 'Àõ','ograve': '√≤','ogt': '‚ßÅ',
        'ohbar': '‚¶µ','ohm': 'Œ©','oint': '‚àÆ','olarr': '‚Ü∫','olcir': '‚¶æ',
        'olcross': '‚¶ª','oline': '‚Äæ','olt': '‚ßÄ','omacr': '≈ç','omega': 'œâ',
        'omicron': 'Œø','omid': '‚¶∂','ominus': '‚äñ','oopf': 'ùï†','opar': '‚¶∑',
        'operp': '‚¶π','oplus': '‚äï','or': '‚à®','orarr': '‚Üª','ord': '‚©ù',
        'order': '‚Ñ¥','orderof': '‚Ñ¥','ordf': '¬™','ordm': '¬∫','origof': '‚ä∂',
        'oror': '‚©ñ','orslope': '‚©ó','orv': '‚©õ','oscr': '‚Ñ¥','oslash': '√∏',
        'osol': '‚äò','otilde': '√µ','otimes': '‚äó','otimesas': '‚®∂','ouml': '√∂',
        'ovbar': '‚åΩ','par': '‚à•','para': '¬∂','parallel': '‚à•','parsim': '‚´≥',
        'parsl': '‚´Ω','part': '‚àÇ','pcy': '–ø','percnt': '%','period': '.',
        'permil': '‚Ä∞','perp': '‚ä•','pertenk': '‚Ä±','pfr': 'ùî≠','phi': 'œÜ',
        'phiv': 'œï','phmmat': '‚Ñ≥','phone': '‚òé','pi': 'œÄ','pitchfork': '‚ãî',
        'piv': 'œñ','planck': '‚Ñè','planckh': '‚Ñé','plankv': '‚Ñè','plus': '+',
        'plusacir': '‚®£','plusb': '‚äû','pluscir': '‚®¢','plusdo': '‚àî','plusdu': '‚®•',
        'pluse': '‚©≤','plusmn': '¬±','plussim': '‚®¶','plustwo': '‚®ß','pm': '¬±',
        'pointint': '‚®ï','popf': 'ùï°','pound': '¬£','pr': '‚â∫','prE': '‚™≥',
        'prap': '‚™∑','prcue': '‚âº','pre': '‚™Ø','prec': '‚â∫','precapprox': '‚™∑',
        'preccurlyeq': '‚âº','preceq': '‚™Ø','precnapprox': '‚™π','precneqq': '‚™µ','precnsim': '‚ã®',
        'precsim': '‚âæ','prime': '‚Ä≤','primes': '‚Ñô','prnE': '‚™µ','prnap': '‚™π',
        'prnsim': '‚ã®','prod': '‚àè','profalar': '‚åÆ','profline': '‚åí','profsurf': '‚åì',
        'prop': '‚àù','propto': '‚àù','prsim': '‚âæ','prurel': '‚ä∞','pscr': 'ùìÖ',
        'psi': 'œà','puncsp': '‚Äà','qfr': 'ùîÆ','qint': '‚®å','qopf': 'ùï¢',
        'qprime': '‚Åó','qscr': 'ùìÜ','quaternions': '‚Ñç','quatint': '‚®ñ','quest': '?',
        'questeq': '‚âü','quot': '"','rAarr': '‚áõ','rArr': '‚áí','rAtail': '‚§ú',
        'rBarr': '‚§è','rHar': '‚•§','race': '‚àΩÃ±','racute': '≈ï','radic': '‚àö',
        'raemptyv': '‚¶≥','rang': '‚ü©','rangd': '‚¶í','range': '‚¶•','rangle': '‚ü©',
        'raquo': '¬ª','rarr': '‚Üí','rarrap': '‚•µ','rarrb': '‚á•','rarrbfs': '‚§†',
        'rarrc': '‚§≥','rarrfs': '‚§û','rarrhk': '‚Ü™','rarrlp': '‚Ü¨','rarrpl': '‚•Ö',
        'rarrsim': '‚•¥','rarrtl': '‚Ü£','rarrw': '‚Üù','ratail': '‚§ö','ratio': '‚à∂',
        'rationals': '‚Ñö','rbarr': '‚§ç','rbbrk': '‚ù≥','rbrace': '}','rbrack': ']',
        'rbrke': '‚¶å','rbrksld': '‚¶é','rbrkslu': '‚¶ê','rcaron': '≈ô','rcedil': '≈ó',
        'rceil': '‚åâ','rcub': '}','rcy': '—Ä','rdca': '‚§∑','rdldhar': '‚•©',
        'rdquo': '‚Äù','rdquor': '‚Äù','rdsh': '‚Ü≥','real': '‚Ñú','realine': '‚Ñõ',
        'realpart': '‚Ñú','reals': '‚Ñù','rect': '‚ñ≠','reg': '¬Æ','rfisht': '‚•Ω',
        'rfloor': '‚åã','rfr': 'ùîØ','rhard': '‚áÅ','rharu': '‚áÄ','rharul': '‚•¨',
        'rho': 'œÅ','rhov': 'œ±','rightarrow': '‚Üí','rightarrowtail': '‚Ü£','rightharpoondown': '‚áÅ',
        'rightharpoonup': '‚áÄ','rightleftarrows': '‚áÑ','rightleftharpoons': '‚áå','rightrightarrows': '‚áâ','rightsquigarrow': '‚Üù',
        'rightthreetimes': '‚ãå','ring': 'Àö','risingdotseq': '‚âì','rlarr': '‚áÑ','rlhar': '‚áå',
        'rlm': '','rmoust': '‚é±','rmoustache': '‚é±','rnmid': '‚´Æ','roang': '‚ü≠',
        'roarr': '‚áæ','robrk': '‚üß','ropar': '‚¶Ü','ropf': 'ùï£','roplus': '‚®Æ',
        'rotimes': '‚®µ','rpar': ')','rpargt': '‚¶î','rppolint': '‚®í','rrarr': '‚áâ',
        'rsaquo': '‚Ä∫','rscr': 'ùìá','rsh': '‚Ü±','rsqb': ']','rsquo': '‚Äô',
        'rsquor': '‚Äô','rthree': '‚ãå','rtimes': '‚ãä','rtri': '‚ñπ','rtrie': '‚äµ',
        'rtrif': '‚ñ∏','rtriltri': '‚ßé','ruluhar': '‚•®','rx': '‚Ñû','sacute': '≈õ',
        'sbquo': '‚Äö','sc': '‚âª','scE': '‚™¥','scap': '‚™∏','scaron': '≈°',
        'sccue': '‚âΩ','sce': '‚™∞','scedil': '≈ü','scirc': '≈ù','scnE': '‚™∂',
        'scnap': '‚™∫','scnsim': '‚ã©','scpolint': '‚®ì','scsim': '‚âø','scy': '—Å',
        'sdot': '‚ãÖ','sdotb': '‚ä°','sdote': '‚©¶','seArr': '‚áò','searhk': '‚§•',
        'searr': '‚Üò','searrow': '‚Üò','sect': '¬ß','semi': '','seswar': '‚§©',
        'setminus': '‚àñ','setmn': '‚àñ','sext': '‚ú∂','sfr': 'ùî∞','sfrown': '‚å¢',
        'sharp': '‚ôØ','shchcy': '—â','shcy': '—à','shortmid': '‚à£','shortparallel': '‚à•',
        'shy': '','sigma': 'œÉ','sigmaf': 'œÇ','sigmav': 'œÇ','sim': '‚àº',
        'simdot': '‚©™','sime': '‚âÉ','simeq': '‚âÉ','simg': '‚™û','simgE': '‚™†',
        'siml': '‚™ù','simlE': '‚™ü','simne': '‚âÜ','simplus': '‚®§','simrarr': '‚•≤',
        'slarr': '‚Üê','smallsetminus': '‚àñ','smashp': '‚®≥','smeparsl': '‚ß§','smid': '‚à£',
        'smile': '‚å£','smt': '‚™™','smte': '‚™¨','smtes': '‚™¨Ô∏Ä','softcy': '—å',
        'sol': '/','solb': '‚ßÑ','solbar': '‚åø','sopf': 'ùï§','spades': '‚ô†',
        'spadesuit': '‚ô†','spar': '‚à•','sqcap': '‚äì','sqcaps': '‚äìÔ∏Ä','sqcup': '‚äî',
        'sqcups': '‚äîÔ∏Ä','sqsub': '‚äè','sqsube': '‚äë','sqsubset': '‚äè','sqsubseteq': '‚äë',
        'sqsup': '‚äê','sqsupe': '‚äí','sqsupset': '‚äê','sqsupseteq': '‚äí','squ': '‚ñ°',
        'square': '‚ñ°','squarf': '‚ñ™','squf': '‚ñ™','srarr': '‚Üí','sscr': 'ùìà',
        'ssetmn': '‚àñ','ssmile': '‚å£','sstarf': '‚ãÜ','star': '‚òÜ','starf': '‚òÖ',
        'straightepsilon': 'œµ','straightphi': 'œï','strns': '¬Ø','sub': '‚äÇ','subE': '‚´Ö',
        'subdot': '‚™Ω','sube': '‚äÜ','subedot': '‚´É','submult': '‚´Å','subnE': '‚´ã',
        'subne': '‚ää','subplus': '‚™ø','subrarr': '‚•π','subset': '‚äÇ','subseteq': '‚äÜ',
        'subseteqq': '‚´Ö','subsetneq': '‚ää','subsetneqq': '‚´ã','subsim': '‚´á','subsub': '‚´ï',
        'subsup': '‚´ì','succ': '‚âª','succapprox': '‚™∏','succcurlyeq': '‚âΩ','succeq': '‚™∞',
        'succnapprox': '‚™∫','succneqq': '‚™∂','succnsim': '‚ã©','succsim': '‚âø','sum': '‚àë',
        'sung': '‚ô™','sup1': '¬π','sup2': '¬≤','sup3': '¬≥','sup': '‚äÉ',
        'supE': '‚´Ü','supdot': '‚™æ','supdsub': '‚´ò','supe': '‚äá','supedot': '‚´Ñ',
        'suphsol': '‚üâ','suphsub': '‚´ó','suplarr': '‚•ª','supmult': '‚´Ç','supnE': '‚´å',
        'supne': '‚äã','supplus': '‚´Ä','supset': '‚äÉ','supseteq': '‚äá','supseteqq': '‚´Ü',
        'supsetneq': '‚äã','supsetneqq': '‚´å','supsim': '‚´à','supsub': '‚´î','supsup': '‚´ñ',
        'swArr': '‚áô','swarhk': '‚§¶','swarr': '‚Üô','swarrow': '‚Üô','swnwar': '‚§™',
        'szlig': '√ü','target': '‚åñ','tau': 'œÑ','tbrk': '‚é¥','tcaron': '≈•',
        'tcedil': '≈£','tcy': '—Ç','tdot': '‚Éõ','telrec': '‚åï','tfr': 'ùî±',
        'there4': '‚à¥','therefore': '‚à¥','theta': 'Œ∏','thetasym': 'œë','thetav': 'œë',
        'thickapprox': '‚âà','thicksim': '‚àº','thinsp': '‚Äâ','thkap': '‚âà','thksim': '‚àº',
        'thorn': '√æ','tilde': 'Àú','times': '√ó','timesb': '‚ä†','timesbar': '‚®±',
        'timesd': '‚®∞','tint': '‚à≠','toea': '‚§®','top': '‚ä§','topbot': '‚å∂',
        'topcir': '‚´±','topf': 'ùï•','topfork': '‚´ö','tosa': '‚§©','tprime': '‚Ä¥',
        'trade': '‚Ñ¢','triangle': '‚ñµ','triangledown': '‚ñø','triangleleft': '‚óÉ','trianglelefteq': '‚ä¥',
        'triangleq': '‚âú','triangleright': '‚ñπ','trianglerighteq': '‚äµ','tridot': '‚ó¨','trie': '‚âú',
        'triminus': '‚®∫','triplus': '‚®π','trisb': '‚ßç','tritime': '‚®ª','trpezium': '‚è¢',
        'tscr': 'ùìâ','tscy': '—Ü','tshcy': '—õ','tstrok': '≈ß','twixt': '‚â¨',
        'twoheadleftarrow': '‚Üû','twoheadrightarrow': '‚Ü†','uArr': '‚áë','uHar': '‚•£','uacute': '√∫',
        'uarr': '‚Üë','ubrcy': '—û','ubreve': '≈≠','ucirc': '√ª','ucy': '—É',
        'udarr': '‚áÖ','udblac': '≈±','udhar': '‚•Æ','ufisht': '‚•æ','ufr': 'ùî≤',
        'ugrave': '√π','uharl': '‚Üø','uharr': '‚Üæ','uhblk': '‚ñÄ','ulcorn': '‚åú',
        'ulcorner': '‚åú','ulcrop': '‚åè','ultri': '‚ó∏','umacr': '≈´','uml': '¬®',
        'uogon': '≈≥','uopf': 'ùï¶','uparrow': '‚Üë','updownarrow': '‚Üï','upharpoonleft': '‚Üø',
        'upharpoonright': '‚Üæ','uplus': '‚äé','upsi': 'œÖ','upsih': 'œí','upsilon': 'œÖ',
        'upuparrows': '‚áà','urcorn': '‚åù','urcorner': '‚åù','urcrop': '‚åé','uring': '≈Ø',
        'urtri': '‚óπ','uscr': 'ùìä','utdot': '‚ã∞','utilde': '≈©','utri': '‚ñµ',
        'utrif': '‚ñ¥','uuarr': '‚áà','uuml': '√º','uwangle': '‚¶ß','vArr': '‚áï',
        'vBar': '‚´®','vBarv': '‚´©','vDash': '‚ä®','vangrt': '‚¶ú','varepsilon': 'œµ',
        'varkappa': 'œ∞','varnothing': '‚àÖ','varphi': 'œï','varpi': 'œñ','varpropto': '‚àù',
        'varr': '‚Üï','varrho': 'œ±','varsigma': 'œÇ','varsubsetneq': '‚ääÔ∏Ä','varsubsetneqq': '‚´ãÔ∏Ä',
        'varsupsetneq': '‚äãÔ∏Ä','varsupsetneqq': '‚´åÔ∏Ä','vartheta': 'œë','vartriangleleft': '‚ä≤','vartriangleright': '‚ä≥',
        'vcy': '–≤','vdash': '‚ä¢','vee': '‚à®','veebar': '‚äª','veeeq': '‚âö',
        'vellip': '‚ãÆ','verbar': '|','vert': '|','vfr': 'ùî≥','vltri': '‚ä≤',
        'vnsub': '‚äÇ‚Éí','vnsup': '‚äÉ‚Éí','vopf': 'ùïß','vprop': '‚àù','vrtri': '‚ä≥',
        'vscr': 'ùìã','vsubnE': '‚´ãÔ∏Ä','vsubne': '‚ääÔ∏Ä','vsupnE': '‚´åÔ∏Ä','vsupne': '‚äãÔ∏Ä',
        'vzigzag': '‚¶ö','wcirc': '≈µ','wedbar': '‚©ü','wedge': '‚àß','wedgeq': '‚âô',
        'weierp': '‚Ñò','wfr': 'ùî¥','wopf': 'ùï®','wp': '‚Ñò','wr': '‚âÄ',
        'wreath': '‚âÄ','wscr': 'ùìå','xcap': '‚ãÇ','xcirc': '‚óØ','xcup': '‚ãÉ',
        'xdtri': '‚ñΩ','xfr': 'ùîµ','xhArr': '‚ü∫','xharr': '‚ü∑','xi': 'Œæ',
        'xlArr': '‚ü∏','xlarr': '‚üµ','xmap': '‚üº','xnis': '‚ãª','xodot': '‚®Ä',
        'xopf': 'ùï©','xoplus': '‚®Å','xotime': '‚®Ç','xrArr': '‚üπ','xrarr': '‚ü∂',
        'xscr': 'ùìç','xsqcup': '‚®Ü','xuplus': '‚®Ñ','xutri': '‚ñ≥','xvee': '‚ãÅ',
        'xwedge': '‚ãÄ','yacute': '√Ω','yacy': '—è','ycirc': '≈∑','ycy': '—ã',
        'yen': '¬•','yfr': 'ùî∂','yicy': '—ó','yopf': 'ùï™','yscr': 'ùìé',
        'yucy': '—é','yuml': '√ø','zacute': '≈∫','zcaron': '≈æ','zcy': '–∑',
        'zdot': '≈º','zeetrf': '‚Ñ®','zeta': 'Œ∂','zfr': 'ùî∑','zhcy': '–∂',
};

// Returns a floating number from the version string, it assumes common semver format as major.minor.patch, all non-digits will
// be removed, underscores will be treated as dots. Returns a floating number which can be used in comparing versions.
//
// Example
//      > lib.toVersion("1.0.3")
//      1.000003
//      > lib.toVersion("1.0.3.4")
//      1.000003004
//      > lib.toVersion("1.0.3.4") > lib.toVersion("1.0.3")
//      true
//      > lib.toVersion("1.0.3.4") > lib.toVersion("1.0.0")
//      true
//      > lib.toVersion("1.0.3.4") > lib.toVersion("1.1.0")
//      false
lib.toVersion = function(str)
{
    return str ? String(str).replace("_", ".").replace(/[^0-9.]/g, "").split(".").reduce(function(x,y,i) { return x + Number(y) / Math.pow(10, i * 3) }, 0) : 0;
}

// Convert text into capitalized words
lib.toTitle = function(name)
{
    return typeof name == "string" ? name.replace(/_/g, " ").split(/[ ]+/).reduce(function(x,y) {
        return x + (y ? (y.substr(0,1).toUpperCase() + y.substr(1).toLowerCase() + " ") : "")
    }, "").trim() : "";
}

// Convert into camelized form, optional chars can define the separators, default is -, _ and .
lib.toCamel = function(name, chars)
{
    var rx = typeof chars == "string" ? new RegExp("(?:[" + chars + "])(\\w)", "g") : this.rxCamel;
    return typeof name == "string" ? name.substr(0, 1).toLowerCase() + name.substr(1).replace(rx, function (_, c) { return c ? c.toUpperCase () : ''; }) : "";
}

// Convert Camel names into names separated by the given separator or dash if not.
lib.toUncamel = function(str, sep)
{
    return typeof str == "string" ? str.replace(/([A-Z])/g, function(_, c, index) { return (index ? sep || '-' : '') + c.toLowerCase(); }) : "";
}

// Safe version, uses 0 instead of NaN, handle booleans, if float specified, returns as float.
//
// Options:
//  - dflt - default value
//  - float - treat as floating number
//  - min - minimal value, clip
//  - max - maximum value, clip
//  - incr - a number to add before checking for other conditions
//  - mult - a number to multiply before checking for other conditions
//  - novalue - replace this number with default
//  - zero - replace with this number if result is 0
//
// Example:
//
//               lib.toNumber("123")
//               lib.toNumber("1.23", { float: 1, dflt: 0, min: 0, max: 2 })
//
lib.toNumber = function(val, options, float)
{
    var n = 0;
    if (typeof val == "number") {
        n = val;
    } else
    if (typeof val == "boolean") {
        n = val ? 1 : 0;
    } else {
        if (typeof val != "string") {
            n = options && options.dflt || 0;
        } else {
            // Autodetect floating number
            var f = typeof options?.float == "undefined" || options?.float == null ? this.rxFloat.test(val) : options?.float || float;
            n = val[0] == 't' ? 1 : val[0] == 'f' ? 0 : val == "infinity" ? Infinity : (f ? parseFloat(val, 10) : parseInt(val, 10));
        }
    }
    n = isNaN(n) ? (options && options.dflt || 0) : n;
    if (options) {
        if (typeof options.novalue == "number" && n === options.novalue) n = options.dflt || 0;
        if (typeof options.incr == "number") n += options.incr;
        if (typeof options.mult == "number") n *= options.mult;
        if (isNaN(n)) n = options.dflt || 0;
        if (typeof options.min == "number" && n < options.min) n = options.min;
        if (typeof options.max == "number" && n > options.max) n = options.max;
        if (typeof options.float != "undefined" && !options.float) n = Math.round(n);
        if (typeof options.zero == "number" && !n) n = options.zero;
    }
    return n;
}

// Strip all non-digit characters from a string
lib.toDigits = function(str)
{
    return (typeof str == "string" ? str : String(str)).replace(this.rxNoDigits, "");
}

// Return a number clamped between the range
lib.toClamp = function(num, min, max)
{
  return Math.max(lib.toNumber(min), Math.min(lib.toNumber(num), lib.toNumber(max)));
}

// Return true if value represents true condition, i.e. non empty value
lib.toBool = function(val, dflt)
{
    if (typeof val == "boolean") return val;
    if (typeof val == "number") return !!val;
    if (typeof val == "undefined") val = dflt;
    if (typeof val == "function") val = dflt;
    return !val || String(val).trim().match(/^(false|off|nil|null|no|f|n|0$)/i) ? false : true;
}

// Return Date object for given text or numeric date representation, for invalid date returns 1969 unless `invalid` parameter is given,
// in this case invalid date returned as null. If `dflt` is NaN, null or 0 returns null as well.
lib.toDate = function(val, dflt, invalid)
{
    if (this.isDate(val)) return val;
    var d = NaN;
    // String that looks like a number
    if (typeof val == "string") {
        val = /^[0-9.]+$/.test(val) ? this.toNumber(val) : val.replace(/([0-9])(AM|PM)/i, "$1 $2");
    }
    if (typeof val == "number") {
        // Convert nanoseconds to milliseconds
        if (val > 2147485547000) val = Math.round(val / 1000);
        // Convert seconds to milliseconds
        if (val < 2147483647) val *= 1000;
    }
    // Remove unsupported timezone names
    if (typeof val == "string") {
        var gmt = val.indexOf("GMT") > -1;
        for (const i in this.tzMap) {
            if ((gmt || this.tzMap[i][3] === false) && val.indexOf(this.tzMap[i][0]) > -1) {
                val = val.replace(this.tzMap[i][0], "");
            }
        }
    }
    if (typeof val != "string" && typeof val != "number") val = d;
    if (val) try { d = new Date(val); } catch (e) {}
    return this.isDate(d) ? d : invalid || (dflt !== undefined && isNaN(dflt)) || dflt === null || dflt === 0 ? null : new Date(dflt || 0);
}

// Return milliseconds from the date or date string, only number as dflt is supported, for invalid dates returns 0
lib.toMtime = function(val, dflt)
{
    val = this.toDate(val, null);
    return val ? val.getTime() : typeof dflt == "number" ? dflt : 0;
}

// Return base62 representation for a number
lib.toBase62 = function(num, alphabet)
{
    var s = '';
    if (Array.isArray(num) && typeof num[0] == "number") num = Buffer.alloc(num);
    if (Buffer.isBuffer(num)) {
        for (var i = 0; i < num.length - 3; i += 4) {
            s += this.toBase62(num.readUInt32LE(i), alphabet);
        }
    } else {
        if (!alphabet) alphabet = this.base62Dict;
        while (num > 0) {
            s = alphabet[num % alphabet.length] + s;
            num = Math.floor(num/alphabet.length);
        }
    }
    return s;
}

// Return a well formatted and validated url or empty string
lib.toUrl = function(val, options)
{
    if (val) try { return new URL(val).toString() } catch (e) {}
    return "";
}

// Return a test representation of a number according to the money formatting rules, default is en-US, options may include:
// currency(USD), display(symbol), sign(standard), min(2), max(3)
lib.toPrice = function(num, options)
{
    try {
        return this.toNumber(num).toLocaleString(options?.locale || "en-US", { style: 'currency',
            currency: options?.currency || 'USD',
            currencyDisplay: options?.display || "symbol",
            currencySign: options?.sign || "standard",
            minimumFractionDigits: options?.min || 2,
            maximumFractionDigits: options?.max || 3 });
    } catch (e) {
        logger.error("toPrice:", e, num, options);
        return "";
    }
}

// Return an email address if valid, `options.parse` makes it extract the email from `name <email>` format
lib.toEmail = function(val, options)
{
    if (typeof val != "string" || val.indexOf("..") > -1) return "";
    if (options?.parse) {
        var s = val.indexOf('<');
        if (s >= 0) {
            var e = val.indexOf('>', s);
            if (e > 0) val = val.substring(s + 1, e);
        }
    }
    return this.rxEmail.test(val) ? val.trim().toLowerCase() : "";
}


// Convert a value to the proper type, default is to return a string or convert the value to a string if no type is specified,
// special case if the type is "" or null return the value as is without any conversion
lib.toValue = function(val, type, options)
{
    if (type === null || type === "") return val;
    type = typeof type == "string" && type.trim() || type;
    switch (type) {
    case "auto":
        if (typeof val == "undefined" || val === null) return "";
        if (typeof val == "string") {
            type = this.isNumeric(val) ? "number":
                   val == "true" || val == "false" ? "bool":
                   val[0] == "^" && val.slice(-1) == "$" ? "regexp":
                   val[0] == "[" && val.slice(-1) == "]" ? "js":
                   val[0] == "{" && val.slice(-1) == "}" ? "js":
                   val.indexOf("|") > -1 && !val.match(/[()[\]^$]/) ? "list": "";
        }
        return this.toValue(val, type, options);

    case "js":
        if (typeof val == "string") val = this.jsonParse(val, options);
        return val;

    case "set":
    case "list":
    case 'array':
        return this.strSplitUnique(val, options?.separator, options);

    case "map":
        return lib.strSplit(val, options?.delimiter || ",").
               map((y) => (lib.strSplit(y, options?.separator || /[:;]/, options))).
               reduce((a, b) => {
                  if (b.length < 2) return a;
                  a[b[0]] = b.length == 2 ? b[1] : b.slice(1);
                  if (options?.maptype) a[b[0]] = lib.toValue(a[b[0]], options.maptype);
                  return a;
        }, {});

    case "expr":
    case "buffer":
        return val;

    case "real":
    case "float":
    case "double":
    case "decimal":
        return this.toNumber(val, options, 1);

    case "int":
    case "int32":
    case "long":
    case "smallint":
    case "integer":
    case "number":
    case "bigint":
    case "numeric":
    case "counter":
    case "now":
    case "clock":
    case "ttl":
        return this.toNumber(val, options);

    case "bool":
    case "boolean":
        return this.toBool(val, options?.dflt);

    case "date":
    case "time":
    case "timestamp":
        return this.toDate(val, options?.dflt);

    case "regexp":
        return this.toRegexp(val, options);

    case "mtime":
        return val ? this.toDate(val, options?.dflt).getTime() : 0;

    case "url":
        return this.toUrl(val, options);

    case "email":
        return this.toEmail(val, options);

    case "phone":
    case "e164":
        if (typeof val == "number") {
            // Keep US phones without 1
            if (type[0] == "p" && val < 19999999999 && val > 10000000000) val -= 10000000000;
            if (type[0] == "e" && val < 10000000000) val += 10000000000;
            val = String(val);
        } else {
            if (typeof val != "string") return "";
            var d = val.match(this.rxPhone);
            if (!d) return "";
            val = this.toDigits(d[1]).slice(0, 15);
        }
        var min = typeof options?.min == "number" ? options.min : 5;
        if (min && val.length < min) return "";
        // Keep US phones without 1
        if (type[0] == "p" && val.length == 11 && val[0] == "1") val = val.substr(1);
        if (type[0] == "e" && val.length == 10) val = "1" + val;
        if (options?.max > 0 && val.length > options.max) return "";
        return val;

    case "json":
        return this.stringify(val);

    case "lower":
        return String(val).toLowerCase();

    case "upper":
        return String(val).toUpperCase();

    case "symbol":
        return this.rxSymbol.test(val) ? val : "";

    default:
        if (typeof options?.toValue == "function") return options.toValue(val, options);
        return typeof val == "string" ? val : typeof val == "undefined" || val === null ? "" : String(val);
    }
}

// Serialize regexp with a custom format, `lib.toRegxp`` will be able to use it
RegExp.prototype.toJSON = function()
{
    return `^/${this.source}/${this.flags}$`;
}

// Safely create a regexp object, if invalid returns undefined, the options can be a string with srandard RegExp
// flags or an object with the following properties:
// - ingoreCase - similar to i
// - globalMatch - similar to m
// - multiLine - similar to m
// - unicode - similar to u
// - sticky - similar to y
// - escape - escape all special symbols or symbol e
lib.toRegexp = function(str, options)
{
    try {
        // Check for JSON stringified format
        if (str && str[0] == "^" && str[str.length - 1] == "$" && str[1] == "/") {
            const e = str.lastIndexOf("/");
            if (e > -1) {
                options = str.slice(e + 1, -1)
                str = str.slice(2, e);
            }
        }
        var flags = typeof options == "string" && /^[igmuye]+$/.test(options) ? options :
                    options ? (options.ignoreCase ? "i" : "") +
                              (options.globalMatch ? "g" : "") +
                              (options.multiLine ? "m" : "") +
                              (options.unicode ? "u" : "") +
                              (options.escape ? "e" : "") +
                              (options.sticky ? "y" : "") : "";
        if (flags.indexOf("e") > -1) {
            if (str) str = str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            flags = flags.replace("e", "");
        }
        return new RegExp(str, flags);
    } catch (e) {
        logger.error('toRegexp:', str, options, e);
    }
}

// Add a regexp to the list of regexp objects, this is used in the config type `regexpmap`.
lib.toRegexpMap = function(obj, val, options)
{
    if (val == null) return [];
    if (this.typeName(obj) != "array") obj = [];
    if (options && options.set) obj = [];
    val = this.jsonParse(val, { datatype: "obj", logger: "error" });
    if (!val && options && options.errnull) return null;
    for (const p in val) {
        if (obj.some(function(x) {
            var i = x.list.indexOf(p[0] == "!" ? p.substr(1) : p);
            if (i > -1 && p[0] == "!") {
                x.list.splice(i, 1);
                lib.toRegexpObj(x, "", options);
            }
            return i > -1;
        })) continue;
        var item = this.toRegexpObj(null, p, options);
        if (!item) continue;
        item.value = options && options.json ? lib.jsonParse(val[p], options) :
                     options && options.datatype ? lib.toValue(val[p], options) : val[p];
        if (item.reset) obj = [];
        obj.push(item);
    }
    return obj;
}

// Add a regexp to the object that consist of list of patterns and compiled regexp, this is used in the config type `regexpobj`
lib.toRegexpObj = function(obj, val, options)
{
    if (val == null) obj = null;
    if (this.typeName(obj) != "object") obj = {};
    if (!Array.isArray(obj.list)) obj.list = [];
    options = options || this.empty;
    if (val) {
        if (options.del || val[0] == "!") {
            var idx = obj.list.indexOf(val[0] == "!" ? val.substr(1) : val);
            if (idx > -1) obj.list.splice(idx, 1);
        } else {
            if (options.set) obj.list = [];
            if (!Array.isArray(val)) val = [ val ];
            for (var i in val) {
                if (obj.list.indexOf(val[i]) == -1) obj.list.push(val[i]);
            }
        }
    }
    if (obj.list.length) {
        try {
            var str = obj.list.map(function(x) {
                if (options.escape) x = x.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                return "(" + x + ")";
            }).join("|")
            obj.rx = new RegExp(str, options.regexp);
        } catch (e) {
            logger.error('toRegexpObj:', val, e);
            if (options.errnull) return null;
        }
    } else {
        obj.rx = null;
    }
    return obj;
}

// Return duration in human format, mtime is msecs
lib.toDuration = function(mtime, options)
{
    var str = "";
    mtime = typeof mtime == "number" ? mtime : this.toNumber(mtime);
    if (mtime > 0) {
        var lang = options && options.lang;
        var seconds = Math.floor(mtime/1000);
        var d = Math.floor(seconds / 86400);
        var h = Math.floor((seconds - d * 86400) / 3600);
        var m = Math.floor((seconds - d * 86400 - h * 3600) / 60);
        var s = Math.floor(seconds - d * 86400 - h * 3600 - m * 60);
        if (d > 0) {
            str = d > 1 ? this.__({ phrase: "%s days", lang: lang }, d) :
                          this.__({ phrase: "1 day", lang: lang });
            if (h > 0) str += " " + (h > 1 ? this.__({ phrase: "%s hours", lang: lang }, h) :
                                             this.__({ phrase: "1 hour", lang: lang }));
            if (m > 0) str += " " + (m > 1 ? this.__({ phrase: "%s minutes", lang: lang }, m) :
                                             this.__({ phrase: "1 minute", lang: lang }));
        } else
        if (h > 0) {
            str = h > 1 ? this.__({ phrase: "%s hours", lang: lang }, h) :
                          this.__({ phrase: "1 hour", lang: lang });
            if (m > 0) str += " " + (m > 1 ? this.__({ phrase: "%s minutes", lang: lang }, m) :
                                             this.__({ phrase: "1 minute", lang: lang }));
        } else
        if (m > 0) {
            str = m > 1 ? this.__({ phrase: "%s minutes", lang: lang }, m) :
                          this.__({ phrase: "1 minute", lang: lang });
            if (s > 0) str += " " + (s > 1 ? this.__({ phrase: "%s seconds", lang: lang }, s) :
                                             this.__({ phrase: "1 second", lang: lang }));
        } else {
            str = seconds > 1 ? this.__({ phrase: "%s seconds", lang: lang }, seconds) :
                                this.__({ phrase: "1 second", lang: lang });
        }
    }
    return str;
}

// Given time in msecs, return how long ago it happened
lib.toAge = function(mtime, options)
{
    var str = "";
    mtime = typeof mtime == "number" ? mtime : util.types.isDate(mtime) ? mtime.getTime() : this.toNumber(mtime);
    if (mtime > 0) {
        var lang = options && options.lang;
        var secs = Math.max(0, Math.floor((Date.now() - mtime)/1000));
        var d = Math.floor(secs / 86400);
        var mm = Math.floor(d / 30);
        var w = Math.floor(d / 7);
        var h = Math.floor((secs - d * 86400) / 3600);
        var m = Math.floor((secs - d * 86400 - h * 3600) / 60);
        var s = Math.floor(secs - d * 86400 - h * 3600 - m * 60);
        if (mm > 0) {
            str = mm > 1 ? this.__({ phrase: "%s months", lang: lang }, mm) :
                           this.__({ phrase: "1 month", lang: lang });
            if (d > 0) str += " " + (d > 1 ? this.__({ phrase: "%s days", lang: lang }, d) :
                                             this.__({ phrase: "1 day", lang: lang }));
            if (h > 0) str += " " + (h > 1 ? this.__({ phrase: "%s hours", lang: lang }, h) :
                                             this.__({ phrase: "1 hour", lang: lang }));
        } else
        if (w > 0) {
            str = w > 1 ? this.__({ phrase: "%s weeks", lang: lang }, w) :
                          this.__({ phrase: "1 week", lang: lang });
            if (d > 0) str += " " + (d > 1 ? this.__({ phrase: "%s days", lang: lang }, d) :
                                             this.__({ phrase: "1 day", lang: lang }));
            if (h > 0) str += " " + (h > 1 ? this.__({ phrase: "%s hours", lang: lang }, h) :
                                             this.__({ phrase: "1 hour", lang: lang }));
        } else
        if (d > 0) {
            str = d > 1 ? this.__({ phrase: "%s days", lang: lang }, d) :
                          this.__({ phrase: "1 day", lang: lang });
            if (h > 0) str += " " + (h > 1 ? this.__({ phrase: "%s hours", lang: lang }, h) :
                                             this.__({ phrase: "1 hour", lang: lang }));
            if (m > 0) str += " " + (m > 1 ? this.__({ phrase: "%s minutes", lang: lang }, m) :
                                             this.__({ phrase: "1 minute", lang: lang }));
        } else
        if (h > 0) {
            str = h > 1 ? this.__({ phrase: "%s hours", lang: lang }, h) :
                          this.__({ phrase: "1 hour", lang: lang });
            if (m > 0) str += " " + (m > 1 ? this.__({ phrase: "%s minutes", lang: lang }, m) :
                                             this.__({ phrase: "1 minute", lang: lang }));
        } else
        if (m > 0) {
            str = m > 1 ? this.__({ phrase: "%s minutes", lang: lang }, m) :
                          this.__({ phrase: "1 minute", lang: lang });
            if (s > 0) str += " " + (s > 1 ? this.__({ phrase: "%s seconds", lang: lang }, s) :
                                             this.__({ phrase: "1 second", lang: lang }));
        } else {
            str = secs > 1 ? this.__({ phrase: "%s seconds", lang: lang }, secs) :
                             this.__({ phrase: "1 second", lang: lang });
        }
    }
    return str;
}

// Return size human readable format
lib.toSize = function(size, decimals)
{
    var i = size > 0 ? Math.floor(Math.log(size) / Math.log(1024)) : 0;
    return (size / Math.pow(1024, i)).toFixed(typeof decimals == "number" ? decimals : 2) * 1 + ' ' + [this.__('Bytes'), this.__('KBytes'), this.__('MBytes'), this.__('GBytes'), this.__('TBytes')][i];
}

// Process incoming query and convert parameters according to the type definition, the schema contains the definition of the paramaters against which to
// validate incoming data. It is an object with property names and definitoons that at least must specify the type, all other options are type specific.
//
// Returns a string message on error or an object
//
// The options can define the following global properties:
//  - null - always return null on any error
//  - setnull - if the value is equal this or any value if an array then set property to null, useful to reset lists, maps...
//  - existing - skip properties if not present in the query
//  - prefix - prefix to be used when searching for the parameters in the query, only properties with this prefix will be processed. The resulting
//     object will not have this prefix in the properties.
//  - dprefix - prefix to use when checking for defaults, defaults are checks in this order: dprefix+name, name, *.type, *
//  - defaults - to pass realtime or other custom options for the validation or convertion utilities as the first argument if not defined in the definition,
//     this is the place to customize/add/override global parameter conditions without changing it. Exact parameter name is used or a wildcard in the format
//     `*.type` where type id any valid type supported or just `*` for all parameters.
//
// Schema parameter properties:
//  - type - convert the input to the type format
//  - name - to save a value with different name than in the original query
//  - dflt - use this value if property does not exists or undefined
//  - dfltempty - also use the dflt value for empty properties
//  - required - if true the target value must not be empty, the check is performed after type conversion,
//       if an object it checks the target object using `lib.isMatched`, i.e. all up to this moment parsed parameters, not original input
//  - errmsg - return this error on error or invalid format or required condition
//  - min - minimum length for the target data, returns an error if smaller, for list type will skip item from the list
//  - max -  maximum length alowed, returns an error if longer
//  - trunc - if true and longer than max just truncate the value instead of returning an error or skipping
//  - separator - for list type default separator is `,|`, for map type default is `:;`
//  - delimiter - map type contains elements separated by , by default, use another if commas are expected
//  - regexp - validate input against this regexp and return an error if not matched, for list type skip items not matched
//  - noregexp - validate the input against this regexp and return an error if matched, for list type skip items matched
//  - datatype - convert each value or item into this type, used by string/list types
//  - maptype - for maps convert each value to this type
//  - novalue - if the target value equals this ignore the parameter, can be a list of values to be ignored
//  - ignore - if true skip this parameter
//  - optional - for date types, if true do not assign the current time for empty values
//  - value - assign this value unconditionally
//  - values - a list of allowed values, if not present the parameter is ignored
//  - values_map - an objexct map for values, replace matching values with a new one
//  - params - an object with schema to validate for json/obj/array types
//  - empty - if true and the target value is empty return as empty, by default empty values are ignored
//  - keepempty - for list type keep empty items in the list, default is skip empty items
//  - minlist - min allowed length of the target array for list/map types, returns error if less
//  - maxlist - max allowed length of the target array for list/map types, returns error if longer
//  - strip - a regexp with characters to strip from the final value
//  - upper/lower - transform case
//  - cap - capitalize the value
//  - trim - trim the final value if a string
//  - replace - an object map with characters to be replaced with other values
//
// Supported types:
//   - string types: string, text,
//   - boolean types: bool, boolean,
//   - numeric types: int, bigint, long, number, float, real, double, counter, clock, now, random
//   - object types: list, map, obj, array, json,
//   - date/time types: mtime, date, time, timestamp, datetime
//   - special types: set, email, symbol, url, phone, e164, regexp
//
//
//
// Example:
//
//        var query = lib.toParams(req.query, {
//                id: { type: "int" },
//                count: { type: "int", min: 1, max: 10, dflt: 5 },
//                name: { type: "string", max: 32, trunc: 1 },
//                pair: { type: "map", maptype: "int" },
//                code: { type: "string", regexp: /^[a-z]-[0-9]+$/, errmsg: "Valid code is required" },
//                start: { type: "token", required: 1 },
//                email: { type: "list", datatype: "email", novalue: ["a@a"] },
//                email1: { type: "email", required: { email: null } },
//                data: { type: "json", datatype: "obj" },
//                mtime: { type: "mtime", name: "timestamp" },
//                flag: { type: "bool", novalue: false },
//                descr: { novalue: { name: "name", value: "test" }, replace: { "<": "!" } },
//                internal: { ignore: 1 },
//                tm: { type: "timestamp", optional: 1 },
//                ready: { value: "ready" },
//                state: { values: [ "ok","bad","good" ] },
//                status: { value: [ "ok","done" ] },
//                obj: { type: "obj", params: { id: { type: "int" }, name: {} } },
//                arr: { type: "array", params: { id: { type: "int" }, name: {} } },
//                ssn: { type: "string", regexp: /^[0-9]{3}-[0-9]{3}-[0-9]{4}$/, errmsg: "Valid SSN is required" },
//                phone: { type: "list", datatype: "number" },
//        }, {
//                defaults: {
//                    start: { secret: req.account.secret },
//                    name: { dflt: "test" },
//                    count: { max: 100 },
//                    email: { ignore: req.account.type != "admin" },
//                    "*.string": { max: 255 },
//                    '*': { maxlist: 255 },
//        })
//        if (typeof query == "string) return api.sendReply(res, 400, query);
//
lib.toParams = function(query, schema, options)
{
    var rc = {}, opts, dopts, dflts, p, n, v;
    dflts = options?.defaults || lib.empty;
    for (const name in schema) {
        v = schema[name];
        switch (this.typeName(v)) {
        case "undefined":
            continue;
        case "object":
            if (v.ignore) continue;
            break;
        default:
            v = { value: v };
        }
        opts = {};
        for (const c in v) opts[c] = v[c];
        dopts = (options?.dprefix ? dflts[options.dprefix + name] : null) || dflts[name] || dflts[opts.type ? '*.' + opts.type : '*.string'] || dflts['*'];
        for (const p in dopts) if (typeof opts[p] == "undefined") opts[p] = dopts[p];
        if (opts.ignore) continue;
        n = opts.name || name;
        p = options?.prefix ? options.prefix + name : name;
        if (options?.existing && !(p in query)) continue;
        v = query[p];
        if (options?.setnull && (options.setnull === v || lib.isFlag(options.setnull, v))) {
            rc[n] = null;
            continue;
        }
        if (typeof v == "undefined" || (opts.dfltempty && this.isEmpty(v))) v = opts.dflt;
        if (typeof opts.value != "undefined") {
            var val = opts.value;
            switch (this.typeName(val)) {
            case "object":
                val = [ val ];
            case "array":
                for (var i in val) {
                    var cond = val[i];
                    if (this.isTrue(cond.name ? rc[cond.name] : v, cond.value, cond.op, cond.type || opts.type)) {
                        opts.type = "set";
                        v = cond.set;
                        break;
                    }
                }
                break;
            default:
                opts.type = "set";
                v = val;
            }
        }
        logger.dev("toParams", name, n, typeof v, v, ":", opts);
        switch (opts.type) {
        case "set":
            if (typeof v == "undefined") {
                delete rc[n];
            } else {
                rc[n] = v;
            }
            break;

        case "boolean":
        case "bool":
            if (typeof v != "undefined") rc[n] = this.toBool(v, opts.dflt);
            break;

        case "real":
        case "float":
        case "double":
            opts.float = 1;
        case "int":
        case "long":
        case "number":
        case "bigint":
        case "counter":
        case "clock":
        case "now":
        case "random":
            if (typeof v != "undefined") rc[n] = this.toNumber(v, opts);
            break;

        case "regexp":
            if (typeof v != "string") break;
            if (opts.max > 0 && v.length > opts.max) {
                return options?.null ? null : this.__(opts.errmsg || "%s is too long, the max length is %s", name, opts.max);
            }
            rc[n] = this.toRegexp(v, opts);
            break;

        case "list":
            if (!v && !opts.empty) break;
            v = opts.keepempty ? (Array.isArray(v) ? v : this.phraseSplit(v, opts)) : this[opts.unique ? "strSplitUnique" : "strSplit"](v, opts.separator, opts);
            if (Array.isArray(opts.values)) v = v.filter((x) => (opts.values.indexOf(x) > -1));
            if (Array.isArray(opts.novalue)) v = v.filter((x) => (opts.novalue.indexOf(x) == -1));
            if (opts.minlist > 0 && v.length < opts.minlist) {
                return options?.null ? null : this.__(opts.errmsg || "%s is too short, the min size is %s", name, opts.minlist);
            }
            if (opts.maxlist > 0 && v.length > opts.maxlist) {
                if (!opts.trunc) {
                    return options?.null ? null : this.__(opts.errmsg || "%s is too long, the max size is %s", name, opts.maxlist)
                }
                v = v.slice(0, opts.maxlist);
            }
            if ((!v || !v.length) && !opts.empty) break;
            if (v && opts.flatten) v = this.arrayFlatten(v);
            rc[n] = v || [];
            break;

        case "map":
            if (!v && !opts.empty) break;
            v = lib.strSplit(v, opts.delimiter || ",");
            if (opts.maxlist > 0 && v.length > opts.maxlist) {
                if (!opts.trunc) {
                    return options?.null ? null : this.__(opts.errmsg || "%s is too long, the max size is %s", name, opts.maxlist)
                }
                v = v.slice(0, opts.maxlist);
            }
            v = v.map((x) => (lib.strSplit(x, opts.separator || /[:;]/, opts))).
                  reduce((a, b) => {
                      if (b.length < 2) return a;
                      a[b[0]] = b.length == 2 ? b[1] : b.slice(1);
                      if (opts.maptype) a[b[0]] = lib.toValue(a[b[0]], opts.maptype);
                      return a;
                  }, {});
            if (this.isEmpty(v) && !opts.empty) break;
            if (!rc[n]) rc[n] = {};
            for (const p in v) rc[n][p] = v[p];
            break;

        case "obj":
            if (!v && !opts.empty) break;
            v = this.toParams(v || lib.empty, opts.params, { prefix: options?.prefix, dprefix: options?.dprefix, defaults: dflts });
            if (typeof v == "string") return options?.null ? null : v;
            if (opts.max > 0 && lib.objSize(v) > opts.max) {
                return options?.null ? null : this.__(opts.errmsg || "%s is too large, the max size is %s", name, opts.max)
            }
            if (!this.isEmpty(v) || opts.empty) rc[n] = v;
            break;

        case "array":
            if (!v && !opts.empty) break;
            v = lib.isArray(v, []).map((x) => (lib.toParams(x, opts.params, { null: 1, prefix: options?.prefix, dprefix: options?.dprefix, defaults: dflts }))).filter((x) => (x !== null));
            if (opts.minlist > 0 && v.length < opts.minlist) {
                return options?.null ? null : this.__(opts.errmsg || "%s is too short, the min length is %s", name, opts.minlist)
            }
            if (opts.maxlist > 0 && v.length > opts.maxlist) {
                if (!opts.trunc) {
                    return options?.null ? null : this.__(opts.errmsg || "%s is too long, the max length is %s", name, opts.maxlist)
                }
                v = v.slice(0, opts.maxlist);
            }
            if (v.length || opts.empty) rc[n] = v;
            break;

        case "token":
            if (!v) break;
            if (opts.max > 0 && v.length > opts.max) {
                return options?.null ? null : this.__(opts.errmsg || "%s is too long, the max length is %s", name, opts.max);
            }
            rc[n] = this.base64ToJson(v, opts.secret);
            break;

        case "mtime":
            if (!v) break;
            v = this.toDate(v, opts.dflt, true);
            if (v) rc[n] = v.getTime();
            break;

        case "date":
        case "time":
            if (v) rc[n] = this.toDate(v, opts.dflt, true);
            break;

        case "datetime":
            if (!opts.optional && (!v || (typeof v == "boolean" && v))) v = Date.now();
            if (v) v = this.toDate(v, opts.dflt);
            if (v) rc[n] = this.strftime(v, opts.format || "%Y/%m/%d %H:%M");
            break;

        case "timestamp":
            if (!opts.optional && (!v || (typeof v == "boolean" && v))) v = Date.now();
            if (v) v = this.toDate(v, opts.dflt, true);
            if (v) rc[n] = opts.format ? this.strftime(v, opts.format) : v.toISOString();
            break;

        case "json":
            if (typeof v != "string") break;
            if (opts.max > 0 && v.length > opts.max) {
                return options?.null ? null : this.__(opts.errmsg || "%s is too long, the max length is %s", name, opts.max);
            }
            v = this.jsonParse(v, opts);
            if (opts.params) {
                v = this.toParams(v, opts.params, { prefix: options?.prefix, dprefix: options?.dprefix, defaults: dflts });
                if (typeof v == "string") return options?.null ? null : v;
            }
            if (v || opts.empty) rc[n] = v;
            break;

        default:
            if (typeof v == "undefined" || v === null) break;
            v = typeof v == "string" ? v : String(v);
            switch (opts.type) {
            case "symbol":
            case "email":
            case "phone":
            case "e164":
            case "url":
                if (v) {
                    v = this.toValue(v.trim(), opts.type, opts);
                }
                break;
            }
            if (opts.trim) v = v.trim();
            if (opts.max && v.length > opts.max) {
                if (!opts.trunc) {
                    return options?.null ? null : this.__(opts.errmsg || "%s is too long, the max length is %s", name, opts.max);
                }
                v = v.substr(0, opts.max);
            }
            if (opts.min > 0 && v.length < opts.min) {
                return options?.null ? null : this.__(opts.errmsg || "%s is too short, the min length is %s", name, opts.min);
            }
            if (opts.noregexp) {
                const rx = lib.isArray(opts.noregexp, [opts.noregexp]);
                if (rx.some((r) => (lib.testRegexp(v, r)))) {
                    if (!opts.required && opts.errmsg) return options?.null ? null : typeof opts.errmsg == "string" ? opts.errmsg : this.__("invalid characters in %s", name);
                    break;
                }
            } else
            if (opts.regexp) {
                const rx = lib.isArray(opts.regexp, [opts.regexp]);
                if (!rx.some((r) => (lib.testRegexp(v, r)))) {
                    if (!opts.required && opts.errmsg) return options?.null ? null : typeof opts.errmsg == "string" ? opts.errmsg : this.__("invalid characters in %s", name);
                    break;
                }
            }
            if (opts.replace) {
                for (const p in opts.replace) {
                    v = v.replaceAll(p, opts.replace[p]);
                }
            }
            if (opts.strip) v = v.replace(opts.strip, "");
            if (opts.upper) v = v.toUpperCase();
            if (opts.lower) v = v.toLowerCase();
            if (opts.camel) v = lib.toCamel(v, opts.camel);
            if (opts.cap) v = lib.toTitle(v);
            if (opts.datatype) v = lib.toValue(v, opts.datatype, opts);
            if (!v && !opts.empty) break;
            rc[n] = v;
            break;
        }
        v = rc[n];
        if (!this.isEmpty(v) && opts.type != "list") {
            if (Array.isArray(opts.values) && opts.values.indexOf(v) == -1) {
                delete rc[n];
            } else
            // Delete if equal to a special value(s)
            if (Array.isArray(opts.novalue)) {
                if (opts.novalue.length && opts.novalue.indexOf(v) > -1) delete rc[n];
            } else
            if (typeof opts.novalue == "object") {
                if (v === rc[opts.novalue.name] || v === opts.novalue.value) delete rc[n];
            } else
            if (v === opts.novalue) {
                delete rc[n];
            } else
            if (lib.isArray(opts.values_map)) {
                for (let i = 0; i < opts.values_map.length - 1; i += 2) {
                    if (v === opts.values_map[i]) {
                        v = rc[n] = opts.values_map[i + 1];
                        break;
                    }
                }
            }
        }
        // Return an error message
        if (opts.required && this.isEmpty(rc[n])) {
            if (!lib.isObject(opts.required) || this.isMatched(rc, opts.required)) {
                return options?.null ? null : opts.errmsg || this.__("%s is required", name);
            }
        }
    }
    return rc;
}

// Convert a list of records into the specified format, supported formats are: `xml, csv, json, jsontext`.
// - For `csv` the default separator is comma but can be specified with `options.separator`. To produce columns header specify `options.header`.
// - For `json` format puts each record as a separate JSON object on each line, so to read it back
//   it will require to read every line and parse it and add to the list.
// - For `xml` format the name of the row tag is `<row>` but can be
//   specified with `options.tag`.
//
// All formats support the property `options.allow` which is a list of property names that are allowed only in the output for each record, non-existent
// properties will be replaced by empty strings.
//
// The `mapping` object property can redefine different tag/header names to be put into the file instead of the exact column names from the records.
lib.toFormat = function(format, data, options)
{
    var rows = Array.isArray(data) ? data : Array.isArray(data.data) ? data.data : this.isObject(data) ? [ data ] : [];
    if (!rows.length) return "";
    var allow = this.isArray(options?.allow);
    var v, map = options?.mapping || this.empty, text = "";

    switch (format) {
    case "xml":
        var tag = ((options && options.tag) || "row");
        for (var i = 0; i < rows.length; i++) {
            text += "<" + tag + ">\n";
            text += (allow || Object.keys(rows[i])).map(function(y) {
                v = rows[i][y];
                v = Array.isArray(v) ? v.join(",") : typeof v == "object" ? lib.stringify(v) : String(v || "");
                var t = map[y] || y;
                return "<" + t + ">" + lib.textToXml(v) + "</" + t + ">\n";
            });
            text += "</" + tag + ">\n";
        }
        break;

    case "csv":
        var keys, quotesRx;
        var sep = (options && options.separator) || ",";
        var quotes = (options && options.quotes) || '"';
        var controls = (options && options.controls) || " ";

        if (options && options.header) {
            keys = allow || Object.keys(rows[0]);
            text += keys.map(function(x) { return map[x] || x }).join(sep) + "\r\n";
            options.header = 0;
        }
        for (let i = 0; i < rows.length; i++) {
            keys = allow || Object.keys(rows[i]);
            text += keys.map(function(y) {
                v = rows[i][y];
                v = Array.isArray(v) ? v.join(",") : typeof v == "object" ? lib.stringify(v) : String(v || "");
                if (v) {
                    v = v.replace(/[\r\n\t]/g, controls);
                    if (v.indexOf(sep) > -1 || v.indexOf(quotes) > -1) {
                        if (!quotesRx) quotesRx = new RegExp(quotes, "g");
                        v = quotes + v.replace(quotesRx, quotes + quotes) + quotes;
                    }
                }
                return v;
            }).join(sep) + "\r\n";
        }
        break;

    case "jsontext":
        for (let i = 0; i < rows.length; i++) {
            v = allow ? allow.reduce(function(x,y) { if (!lib.isEmpty(rows[i][y])) x[map[y] || y] = rows[i][y]; return x }, {}) : rows[i];
            text += this.jsonFormat({ [i]: v }, options) + "\n";
        }
        break;

    default:
        for (let i = 0; i < rows.length; i++) {
            v = allow ? allow.reduce(function(x,y) { if (!lib.isEmpty(rows[i][y])) x[map[y] || y] = rows[i][y]; return x }, {}) : rows[i];
            text += lib.stringify(v) + "\n";
        }
    }
    return text;
}

// Given a template with @..@ placeholders, replace each placeholder with the value from the obj.
// The `obj` can be an object or an array of objects in which case all objects will be checked for the value until non empty.
//
// To use @ in the template specify it as @@
//
// The options if given may provide the following:
// - allow - placeholders with a name present in this list will be replaced, all other will be replaced with empty string
// - skip - placeholders with a name present in this list will be ignored, the placeholer will be kept
// - only - placeholders with a name present in this list will be replaced only, all other will be ignored and kept as placeholders
// - encoding - can be url or base64, the replaced values will be encoded accordingly
// - separator1 - left side of the placehoder, default is @
// - separator2 - right side of the placeholder, default is @
//
// Example:
//
//        lib.toTemplate("http://www.site.com/@code@/@id@", { id: 123, code: "YYY" }, { encoding: "url" })
//        lib.toTemplate("Hello @name|friend@!", {})
//
//
lib.toTemplate = function(text, obj, options)
{
    if (typeof text != "string" || !text) return "";
    var i, j, rc = [];
    if (!options) options = {};
    if (!Array.isArray(obj)) obj = [obj];
    for (i = 0; i < obj.length; i++) {
        if (typeof obj[i] == "object" && obj[i]) rc.push(obj[i]);
    }
    var tmpl = "", str = text, sep1 = options.separator1 || "@", sep2 = options.separator2 || sep1;
    while (str) {
        var start = str.indexOf(sep1);
        if (start == -1) {
            tmpl += str;
            break;
        }
        var end = str.indexOf(sep2, start + sep1.length);
        if (end == -1) {
            tmpl += str;
            break;
        }
        var tag = str.substr(start + sep1.length, end - start - sep2.length);
        tmpl += str.substr(0, start);
        str = str.substr(end + sep2.length);
        var d, v = null, dflt = null, field = null, enc = options.encoding;
        if (tag == "") {
            v = sep1;
        } else
        if (tag == "exit") {
            options.exit = 1;
        } else
        if (tag == "RAND") {
            v = Math.random();
        } else
        if (/^if/.test(tag)) {
            // @if type tester,admin@
            // @endif@
            end = str.indexOf(sep1 + "endif" + sep2);
            if (end == -1) continue;
            var body = str.substr(0, end);
            str = str.substr(end + 5 + sep1.length + sep2.length);
            d = tag.match(/^(if|ifnull|ifnotnull|ifne|ifeq|ifgt|ifge|iflt|ifle|ifnot|ifall|ifstr) ([a-zA-Z0-9._-]+) +(.+)$/)
            if (!d) continue;
            var ok, val = null, t = d[2];
            i = t.indexOf(".");
            if (i > 0) {
                field = t.substr(i + 1);
                t = t.substr(0, i);
            }
            for (i = 0; i < rc.length && !val; i++) {
                val = typeof rc[i][t] == "function" ? rc[i][t]() : rc[i][t];
                if (val && field && typeof val == "object") {
                    field = field.split(".");
                    for (j = 0; val && j < field.length; j++) {
                        val = val ? val[field[j]] : undefined;
                        if (typeof val == "function") val = val();
                    }
                }
            }
            switch (d[1]) {
            case "if":
                ok = val && lib.isFlag(lib.strSplit(d[3]), lib.strSplit(val));
                break;
            case "ifnull":
                ok = val === null || val === undefined;
                break;
            case "ifnotnull":
                ok = !!val;
                break;
            case "ifempty":
                ok = lib.isEmpty(val);
                break;
            case "ifne":
                ok = val != d[3];
                break;
            case "ifnot":
                ok = !val || !lib.isFlag(lib.strSplit(d[3]), lib.strSplit(val));
                break;
            case "ifall":
                val = lib.strSplit(val);
                ok = lib.strSplit(d[3]).every(function(x) { return val.indexOf(x) > -1 });
                break;
            case "ifstr":
                ok = lib.testRegexp(val || "", lib.toRegexp(d[3], "i"));
                break;
            case "ifeq":
                ok = val == d[3];
                break;
            case "ifgt":
                ok = val > d[3];
                break;
            case "iflt":
                ok = val < d[3];
                break;
            case "ifge":
                ok = val >= d[3];
                break;
            case "ifle":
                ok = val <= d[3];
                break;
            }
            if (ok) {
                v = this.toTemplate(body, rc, options);
                tag = d[2];
            }
        } else {
            d = tag.match(/^([a-zA-Z0-9._-]+)(\|.+)?$/);
            if (d) {
                tag = d[1];
                if (d[2]) dflt = d[2].substr(1);
                i = tag.indexOf(".");
                if (i > 0) {
                    field = tag.substr(i + 1);
                    tag = tag.substr(0, i);
                }
                if (dflt) {
                    i = dflt.indexOf("|");
                    if (i >= 0) {
                        enc = dflt.substr(i + 1);
                        dflt = dflt.substr(0, i);
                    }
                }
                for (i = 0; i < rc.length && !v; i++) {
                    v = typeof rc[i][tag] == "function" ? rc[i][tag]() : rc[i][tag];
                    if (v && field && typeof v == "object") {
                        field = field.split(".");
                        for (j = 0; v && j < field.length; j++) {
                            v = v ? v[field[j]] : undefined;
                            if (typeof v == "function") v = v();
                        }
                    }
                }
                if (typeof options.preprocess == "function") v = options.preprocess(tag, field, v, dflt, enc);
            } else {
                tmpl += sep1 + tag + sep2;
            }
        }
        if (!v) v = dflt;
        if (v) {
            switch (enc) {
            case "url":
                v = this.encodeURIComponent(v);
                break;
            case "d-url":
                v = this.decodeURIComponent(v);
                break;
            case "base64":
                v = Buffer.from(v).toString("base64");
                break;
            case "d-base64":
                v = Buffer.from(v, "base64").toString();
                break;
            case "entity":
                v = this.textToEntity(v);
                break;
            case "d-entity":
                v = this.entityToText(v);
                break;
            case "strftime":
                v = lib.strftime(v);
                break;
            case "mtime":
                v = lib.toMtime(v);
                break;
            }
        }
        if (Array.isArray(options.allow) && options.allow.indexOf(tag) == -1) continue;
        if (Array.isArray(options.skip) && options.skip.indexOf(tag) > -1) continue;
        if (Array.isArray(options.only) && options.only.indexOf(tag) == -1) continue;
        if (v !== null && v !== undefined) tmpl += v;
        if (options.exit) break;
    }
    if (options.noline) tmpl = tmpl.replace(/[\r\n]/g, "");
    if (options.nospace) tmpl = tmpl.replace(/ {2,}/g, " ").trim();
    return tmpl;
}

// Flags command utility, update flags array and returns a new array, the commands are:
// - add - adds the `name` flags to the list if does not exists
// - concat - same as add but always returns a new list
// - del - removes the flags `name`
// - present - returns only flags that present in the list `name`
// - absent - returns only flags that are not present in the list `name`
lib.toFlags = function(cmd, list, name)
{
    switch (cmd) {
    case "concat":
        list = Array.isArray(list) ? list.slice(0) : [];
    case "add":
        if (!Array.isArray(list)) list = [];
        if (!Array.isArray(name)) {
            if (name && list.indexOf(name) == -1) list.push(name);
        } else {
            name.forEach((x) => { if (list.indexOf(x) == -1) list.push(x) });
        }
        break;

    case "del":
        if (!Array.isArray(list)) return [];
        list = list.filter((x) => (Array.isArray(name) ? name.indexOf(x) == -1 : x != name));
        break;

    case "present":
        if (!Array.isArray(list)) return [];
        if (!Array.isArray(name)) return list;
        list = list.filter((x) => (name.indexOf(x) > -1));
        break;

    case "absent":
        if (!Array.isArray(list)) return [];
        if (!Array.isArray(name)) return list;
        list = list.filter((x) => (name.indexOf(x) == -1));
        break;
    }
    return list;
}

// Return RFC3339 formatted timestamp for a date or current time
lib.toRFC3339 = function (date)
{
    date = date ? date : new Date();
    var offset = date.getTimezoneOffset();
    return this.zeropad(date.getFullYear(), 4)
            + "-" + this.zeropad(date.getMonth() + 1, 2)
            + "-" + this.zeropad(date.getDate(), 2)
            + "T" + this.zeropad(date.getHours(), 2)
            + ":" + this.zeropad(date.getMinutes(), 2)
            + ":" + this.zeropad(date.getSeconds(), 2)
            + "." + this.zeropad(date.getMilliseconds(), 3)
            + (offset > 0 ? "-" : "+")
            + this.zeropad(Math.floor(Math.abs(offset) / 60), 2)
            + ":" + this.zeropad(Math.abs(offset) % 60, 2);
}

// Stringify JSON into base64 string, if secret is given, sign the data with it
lib.jsonToBase64 = function(data, secret, options)
{
    data = this.stringify(data);
    if (secret) return this.encrypt(secret, data, options);
    return Buffer.from(data).toString("base64");
}

// Parse base64 JSON into JavaScript object, in some cases this can be just a number then it is passed as it is, if secret is given verify
// that data is not chnaged and was signed with the same secret
lib.base64ToJson = function(data, secret, options)
{
    var rc = "";
    if (typeof data == "undefined" || data == null) return rc;
    if (secret) data = this.decrypt(secret, data, options);
    try {
        if (typeof data == "number" || (typeof data == "string" && data.match(/^[0-9]+$/))) {
            rc = this.toNumber(data);
        } else {
            if (!secret) data = Buffer.from(data, "base64").toString();
            if (data) rc = JSON.parse(data);
        }
    } catch (e) {
        logger.debug("base64ToJson:", e.stack, data);
    }
    return rc;
}

const _formatPresets = {
    compact: { sbracket1: "", sbracket2: "", cbracket1: "", cbracket2: "", nl1: "\n", nl2: "", quote1: "", quote2: "", comma: "", space: "   ", skipnull: 1, skipempty: 1 },
};

// Nicely format an object with indentations, optional `indentlevel` can be used to control until which level deep
// to use newlines for objects.
lib.jsonFormat = function(obj, options)
{
    if (typeof options == "string") options = { indent: options, __level: 0 };
    if (!options) options = { __level: 0 };
    if (typeof options.__level != "number") options = lib.objClone(options, "__level", 0);

    // Shortcut to parse and format json from the string
    if (typeof obj == "string" && obj != "") {
        if (!/^[[{.+]}]$/.test(obj.trim())) return obj;
        obj = this.jsonParse(obj, { dflt: { data: obj } });
    }
    var preset = _formatPresets[options.preset];
    for (const p in preset) options[p] = preset[p];

    if (!options.indent) options.indent = "";
    if (typeof options.nl1 == "undefined") options.nl1 = "\n";
    if (typeof options.nl2 == "undefined") options.nl2 = "\n";
    if (typeof options.sbracket1 == "undefined") options.sbracket1 = "[";
    if (typeof options.sbracket2 == "undefined") options.sbracket2 = "]";
    if (typeof options.cbracket1 == "undefined") options.cbracket1 = "{";
    if (typeof options.cbracket2 == "undefined") options.cbracket2 = "}";
    if (typeof options.quote1 == "undefined") options.quote1 = '"';
    if (typeof options.quote2 == "undefined") options.quote2 = '"';
    if (typeof options.space == "undefined") options.space = "    ";
    if (typeof options.comma == "undefined") options.comma = ", ";
    if (typeof options.sep == "undefined") options.sep = ", ";

    var type = this.typeName(obj);
    var count = 0, val, h;
    var text = type == "array" ? options.sbracket1 : options.cbracket1;
    // Insert newlines only until specified level deep
    var nline = !options.indentlevel || options.__level < options.indentlevel;

    for (var p in obj) {
        if (options.ignore && options.ignore.test(p)) continue;
        val = obj[p];
        if (typeof options.preprocess == "function") {
            val = options.preprocess(p, val, options);
            if (typeof val == "undefined") continue;
        }
        if (options.skipnull && (val === "" || val === null || val === undefined)) continue;
        if (options.skipempty && this.isEmpty(val)) continue;
        if (options.skipvalue && options.skipvalue.test(val)) continue;
        h = options.hide && options.hide.test(p);
        if (count > 0) {
            text += type == "array" ? options.sep : options.comma;
        }
        if (type != "array") {
            text += ((nline && options.nl1 ? (!options.__level && !count ? "" : options.nl1) + options.indent + options.space : "") +
                     options.quote1 + p + options.quote2 + ": ");
        }
        switch (this.typeName(val)) {
        case "array":
        case "object":
            if (h) {
                text += Array.isArray(val) ? val.length : Object.keys(val).length + "...";
                break;
            }
            if (!options.__seen) options.__seen = [];
            if (options.__seen.indexOf(val) > -1) {
                text += "...";
                break;
            }
            options.__seen.push(val);
            options.indent += options.space;
            options.__level++;
            text += this.jsonFormat(val, options);
            options.__level--;
            options.__seen.pop(val);
            options.indent = options.indent.substr(0, options.indent.length - options.space.length);
            break;
        case "boolean":
        case "number":
            text += h ? "..." : val.toString();
            break;
        case "null":
            text += "null";
            break;
        case "string":
            text += h ? "..." : (options.quote1 + val + options.quote2);
            break;
        default:
            text += ("unknown: " + typeof(val));
        }
        count++;
    }
    text += type == "array" ? options.sbracket2 : ((nline && options.nl2 ? options.nl2 + options.indent : "") + options.cbracket2);
    return text;
}

// JSON stringify without exceptions, on error just returns an empty string and logs the error
lib.stringify = function(obj, replacer, space)
{
    try {
        return this.escapeUnicode(replacer || space ? JSON.stringify(obj, replacer, space) : JSON.stringify(obj));
    } catch (e) {
        logger.error("stringify:", e);
        return "";
    }
}

// Parse data as config format name=value per line, return an array of arguments in comand line format ["-name", value,....]
lib.configParse = function(data, options)
{
    if (!data || typeof data != "string") return [];
    var argv = [], lines = data.split("\n");
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();
        if (!/^([a-z0-9_-]+)/.test(line)) continue;
        line = line.split("=");
        if (options?.obj) {
            if (line[0]) argv[line[0].trim()] = line.slice(1).join('=').trim();
        } else
        if (options?.list) {
            if (line[0]) argv.push([line[0].trim(), line.slice(1).join('=').trim()]);
        } else {
            if (line[0]) argv.push('-' + line[0].trim());
            if (line[1]) argv.push(line.slice(1).join('=').trim());
        }
    }
    return argv;
}

// Silent JSON parse, returns null on error, no exceptions raised.
//
// options can specify the following properties:
//  - datatype - make sure the result is returned as type: obj, list, str
//  - dflt - return this in case of error
//  - logger - report in the log with the specified level, log, debug, ...
lib.jsonParse = function(obj, options)
{
    return _parse("json", obj, options);
}

// Same arguments as for `jsonParse`
lib.xmlParse = function(obj, options)
{
    return _parse("xml", obj, options);
}

// Combined parser with type validation
function _parse(type, obj, options)
{
    if (!obj) return _checkResult(type, lib.newError("empty " + type), obj, options);
    try {
        obj = _parseResult(type, obj, options);
    } catch (err) {
        obj = _checkResult(type, err, obj, options);
    }
    return obj;
}

function _parseResult(type, obj, options)
{
    if (typeof obj == "string") {
        switch (type) {
        case "json":
            obj = JSON.parse(obj);
            break;
        case "xml":
            var opts = { object: true };
            for (var p in options) {
                if (["trim","coerce","sanitize","arrayNotation","reversible"].indexOf(p) > -1) opts[p] = options[p];
            }
            obj = xml2json.toJson(obj, opts);
            break;
        }
    }
    switch (options && options.datatype) {
    case "object":
        if (typeof obj != "object" || !obj) return options.dflt || {};
        break;
    case "obj":
        if (lib.typeName(obj) != "object") return options.dflt || {};
        break;
    case "list":
        if (lib.typeName(obj) != "array") return options.dflt || [];
        break;
    case "str":
        if (lib.typeName(obj) != "string") return options.dflt || "";
        break;
    }
    return obj;
}

// Perform validation of the result type, make sure we return what is expected, this is a helper that is used by other conversion routines
function _checkResult(type, err, obj, options)
{
    if (options) {
        if (options.logger) logger.logger(options.logger, 'parse:', type, options, lib.traceError(err), obj);
        if (options.errnull) return null;
        if (options.dflt) return options.dflt;
        if (options.datatype == "object" || options.datatype == "obj") return {};
        if (options.datatype == "list") return [];
        if (options.datatype == "str") return "";
    }
    return null;
}

// Encode with additional symbols, convert these into percent encoded:
//
//          ! -> %21, * -> %2A, ' -> %27, ( -> %28, ) -> %29
lib.encodeURIComponent = function(str)
{
    if (typeof str == "undefined") return "";
    try {
        return encodeURIComponent(str).replace(/[!'()*]/g, function(m) {
            return m == '!' ? '%21' : m == "'" ? '%27' : m == '(' ? '%28' : m == ')' ? '%29' : m == '*' ? '%2A' : m;
        });
    } catch (e) {
        logger.error("encodeURIComponent:", str, e.stack);
    }
}
lib.escape = lib.encodeURIComponent;

// Convert all Unicode binary symbols into Javascript text representation
lib.escapeUnicode = function(text)
{
    return String(text).replace(/[\u007F-\uFFFF]/g, function(m) {
        return "\\u" + ("0000" + m.charCodeAt(0).toString(16)).substr(-4)
    });
}

// Replace Unicode symbols with ASCII equivalents
lib.unicode2Ascii = function(str)
{
    if (typeof str != "string") return "";
    var rc = "";
    for (var i in str) rc += this.unicodeAsciiMap[str[i]] || str[i];
    return rc.trim();
}

// Convert escaped characters into native symbols
lib.unescape = function(str)
{
    return String(str).replace(/\\(.)/g, function(_, c) {
        switch (c) {
        case '"': return '"';
        case "'": return "'";
        case "f": return "\f";
        case "b": return "\b";
        case "\\": return "\\";
        case "n": return "\n";
        case "r": return "\r";
        case "t": return "\t";
        default: return c;
        }
    });
}

// Convert all special symbols into xml entities
lib.textToXml = function(str)
{
    return String(str || "").replace(/([&<>'":])/g, function(_, n) {
      switch (n) {
      case '&': return '&amp;'
      case '<': return '&lt;'
      case '>': return '&gt;'
      case '"': return '&quot;'
      case "'": return '&apos;'
      default: return n;
      }
    });
}

// Convert all special symbols into html entities
lib.textToEntity = function(str)
{
    if (typeof str != "string") return "";
    if (!this.textEntities) {
        this.textEntities = {};
        for (var p in this.htmlEntities) this.textEntities[this.htmlEntities[p]] = "&" + p + ";";
    }
    return str.replace(/([&<>'":])/g, function(_, n) {
        return lib.textEntities[n] || n;
    });
}

// Convert html entities into their original symbols
lib.entityToText = function(str)
{
    if (typeof str != "string") return "";
    return str.replace(/&(#?[a-zA-Z0-9]+);/g, function(_, n) {
        if (n[0] === '#') return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        return lib.htmlEntities[n.toLowerCase()] || "";
    });
}

// Convert a Buffer into base32 string
lib.toBase32 = function(buf, options)
{
    if (!Buffer.isBuffer(buf)) return "";
    const alphabet = options?.alphabet || this.base32;
    let bits = 0, value = 0, str = "";

    for (let i = 0; i < buf.length; i++) {
        value = (value << 8) | buf[i];
        bits += 8
        while (bits >= 5) {
            str += alphabet[(value >>> (bits - 5)) & 31];
            bits -= 5;
        }
    }
    if (bits > 0) {
        str += alphabet[(value << (5 - bits)) & 31];
    }
    if (options?.padding) {
        while ((str.length % 8) !== 0) str += "=";
    }
    return str;
}

// Convert a string in base32 into a Buffer
lib.fromBase32 = function(str, options)
{
    if (typeof str != "string") return "";
    const alphabet = options?.alphabet || this.base32;
    let bits = 0, value = 0, index = 0, idx;
    const buf = Buffer.alloc((str.length * 5 / 8) | 0);
    for (let i = 0; i < str.length; i++) {
        idx = alphabet.indexOf(str[i]);
        if (idx === -1) return null;
        value = (value << 5) | idx;
        bits += 5;
        if (bits >= 8) {
            buf[index++] = (value >>> (bits - 8)) & 255;
            bits -= 8;
        }
    }
    return buf;
}
